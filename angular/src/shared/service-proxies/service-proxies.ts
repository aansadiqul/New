/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.7.0 (NJsonSchema v9.13.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class ADOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined): Observable<PagedResultDtoOfADOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/ADOrder/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfADOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfADOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfADOrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfADOrderDto.fromJS(resultData200) : new PagedResultDtoOfADOrderDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfADOrderDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @param paymentId (optional) 
     * @return Success
     */
    getReceipt(orderId: number | null | undefined, paymentId: number | null | undefined): Observable<AdReceiptDto> {
        let url_ = this.baseUrl + "/api/services/app/ADOrder/GetReceipt?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceipt(<any>response_);
                } catch (e) {
                    return <Observable<AdReceiptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdReceiptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReceipt(response: HttpResponseBase): Observable<AdReceiptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AdReceiptDto.fromJS(resultData200) : new AdReceiptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdReceiptDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: ADOrderInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ADOrder/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @param reportType (optional) 
     * @return Success
     */
    getReportData(orderId: number | null | undefined, reportType: ReportType | null | undefined): Observable<JSonResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ADOrder/GetReportData?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (reportType !== undefined)
            url_ += "reportType=" + encodeURIComponent("" + reportType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportData(<any>response_);
                } catch (e) {
                    return <Observable<JSonResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JSonResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportData(response: HttpResponseBase): Observable<JSonResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JSonResultDto.fromJS(resultData200) : new JSonResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JSonResultDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getMapData(orderId: number | null | undefined): Observable<JSonResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ADOrder/GetMapData?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMapData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMapData(<any>response_);
                } catch (e) {
                    return <Observable<JSonResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JSonResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMapData(response: HttpResponseBase): Observable<JSonResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JSonResultDto.fromJS(resultData200) : new JSonResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JSonResultDto>(<any>null);
    }

    /**
     * @param accountId (optional) 
     * @return Success
     */
    getAccountDetails(accountId: string | null | undefined): Observable<AccountDto> {
        let url_ = this.baseUrl + "/api/services/app/ADOrder/GetAccountDetails?";
        if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountDetails(<any>response_);
                } catch (e) {
                    return <Observable<AccountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountDetails(response: HttpResponseBase): Observable<AccountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountDto.fromJS(resultData200) : new AccountDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmail(input: AdOrderMailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ADOrder/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ADSearchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined, fromDate: string | null | undefined, toDate: string | null | undefined): Observable<PagedResultDtoOfADSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/ADSearch/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&"; 
        if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfADSearchDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfADSearchDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfADSearchDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfADSearchDto.fromJS(resultData200) : new PagedResultDtoOfADSearchDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfADSearchDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: ADSearchInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ADSearch/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: ADSearchDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ADSearch/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ADSearch/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    postADSearchInput(input: ADSearchInput | null | undefined): Observable<ADCountsDto> {
        let url_ = this.baseUrl + "/api/services/app/ADSearch/PostADSearchInput";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostADSearchInput(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostADSearchInput(<any>response_);
                } catch (e) {
                    return <Observable<ADCountsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ADCountsDto>><any>_observableThrow(response_);
        }));
    }

    protected processPostADSearchInput(response: HttpResponseBase): Observable<ADCountsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ADCountsDto.fromJS(resultData200) : new ADCountsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ADCountsDto>(<any>null);
    }

    /**
     * @param queryId (optional) 
     * @return Success
     */
    getAdSearch(queryId: number | null | undefined): Observable<ADSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/ADSearch/GetAdSearch?";
        if (queryId !== undefined)
            url_ += "queryId=" + encodeURIComponent("" + queryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdSearch(<any>response_);
                } catch (e) {
                    return <Observable<ADSearchDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ADSearchDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdSearch(response: HttpResponseBase): Observable<ADSearchDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ADSearchDto.fromJS(resultData200) : new ADSearchDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ADSearchDto>(<any>null);
    }

    /**
     * @param queryId (optional) 
     * @return Success
     */
    getAdNames(queryId: number | null | undefined): Observable<AdBuyNames> {
        let url_ = this.baseUrl + "/api/services/app/ADSearch/GetAdNames?";
        if (queryId !== undefined)
            url_ += "queryId=" + encodeURIComponent("" + queryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdNames(<any>response_);
                } catch (e) {
                    return <Observable<AdBuyNames>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdBuyNames>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdNames(response: HttpResponseBase): Observable<AdBuyNames> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AdBuyNames.fromJS(resultData200) : new AdBuyNames();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdBuyNames>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updatePurchase(input: ADPurchaseUpdate | null | undefined): Observable<ADNamesDto> {
        let url_ = this.baseUrl + "/api/services/app/ADSearch/UpdatePurchase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePurchase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePurchase(<any>response_);
                } catch (e) {
                    return <Observable<ADNamesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ADNamesDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePurchase(response: HttpResponseBase): Observable<ADNamesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ADNamesDto.fromJS(resultData200) : new ADNamesDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ADNamesDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    postAnalyzeData(input: AnalyzeInput | null | undefined): Observable<BreakdownDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ADSearch/PostAnalyzeData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostAnalyzeData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostAnalyzeData(<any>response_);
                } catch (e) {
                    return <Observable<BreakdownDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BreakdownDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processPostAnalyzeData(response: HttpResponseBase): Observable<BreakdownDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BreakdownDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BreakdownDto[]>(<any>null);
    }
}

@Injectable()
export class AffiliationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAllAsync(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<PagedResultDtoOfSpecialAffiliationDto> {
        let url_ = this.baseUrl + "/api/services/app/Affiliation/GetAllAsync?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAsync(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSpecialAffiliationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSpecialAffiliationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAsync(response: HttpResponseBase): Observable<PagedResultDtoOfSpecialAffiliationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSpecialAffiliationDto.fromJS(resultData200) : new PagedResultDtoOfSpecialAffiliationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSpecialAffiliationDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateTypes(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Affiliation/UpdateTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTypes(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: SpecialAffiliationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Affiliation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param isAllActive (optional) 
     * @return Success
     */
    updateAll(isAllActive: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Affiliation/UpdateAll?";
        if (isAllActive !== undefined)
            url_ += "isAllActive=" + encodeURIComponent("" + isAllActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AMGListServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAllAsync(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<PagedResultDtoOfAMGListDto> {
        let url_ = this.baseUrl + "/api/services/app/AMGList/GetAllAsync?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAsync(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAMGListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAMGListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAsync(response: HttpResponseBase): Observable<PagedResultDtoOfAMGListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAMGListDto.fromJS(resultData200) : new PagedResultDtoOfAMGListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAMGListDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateTypes(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AMGList/UpdateTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTypes(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: AMGListDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AMGList/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param isAllActive (optional) 
     * @return Success
     */
    updateAll(isAllActive: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AMGList/UpdateAll?";
        if (isAllActive !== undefined)
            url_ += "isAllActive=" + encodeURIComponent("" + isAllActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BdOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined): Observable<PagedResultDtoOfBdOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/BdOrder/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBdOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBdOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfBdOrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBdOrderDto.fromJS(resultData200) : new PagedResultDtoOfBdOrderDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBdOrderDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @param paymentId (optional) 
     * @return Success
     */
    getReceipt(orderId: number | null | undefined, paymentId: number | null | undefined): Observable<BdReceiptDto> {
        let url_ = this.baseUrl + "/api/services/app/BdOrder/GetReceipt?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceipt(<any>response_);
                } catch (e) {
                    return <Observable<BdReceiptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BdReceiptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReceipt(response: HttpResponseBase): Observable<BdReceiptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BdReceiptDto.fromJS(resultData200) : new BdReceiptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BdReceiptDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @param purchaseType (optional) 
     * @return Success
     */
    getReportData(orderId: number | null | undefined, purchaseType: PurchaseType | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BdOrder/GetReportData?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (purchaseType !== undefined)
            url_ += "purchaseType=" + encodeURIComponent("" + purchaseType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportData(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: BdOrderInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/BdOrder/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createPurchase(input: PurchaseInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BdOrder/CreatePurchase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePurchase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePurchase(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePurchase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BDSearchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined, fromDate: string | null | undefined, toDate: string | null | undefined): Observable<PagedResultDtoOfBDSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/BDSearch/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&"; 
        if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBDSearchDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBDSearchDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfBDSearchDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBDSearchDto.fromJS(resultData200) : new PagedResultDtoOfBDSearchDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBDSearchDto>(<any>null);
    }

    /**
     * @param queryId (optional) 
     * @return Success
     */
    getBdSearch(queryId: number | null | undefined): Observable<BDSearchDto> {
        let url_ = this.baseUrl + "/api/services/app/BDSearch/GetBdSearch?";
        if (queryId !== undefined)
            url_ += "queryId=" + encodeURIComponent("" + queryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBdSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBdSearch(<any>response_);
                } catch (e) {
                    return <Observable<BDSearchDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BDSearchDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBdSearch(response: HttpResponseBase): Observable<BDSearchDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BDSearchDto.fromJS(resultData200) : new BDSearchDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BDSearchDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: BDSearchInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/BDSearch/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: BDSearchDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BDSearch/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BDSearch/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    postAnalyzeData(input: AnalyzeBDInput | null | undefined): Observable<BreakdownBDDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BDSearch/PostAnalyzeData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostAnalyzeData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostAnalyzeData(<any>response_);
                } catch (e) {
                    return <Observable<BreakdownBDDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BreakdownBDDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processPostAnalyzeData(response: HttpResponseBase): Observable<BreakdownBDDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BreakdownBDDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BreakdownBDDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    postBDSearchInput(input: BDSearchInput | null | undefined): Observable<BDCountsDto> {
        let url_ = this.baseUrl + "/api/services/app/BDSearch/PostBDSearchInput";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostBDSearchInput(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostBDSearchInput(<any>response_);
                } catch (e) {
                    return <Observable<BDCountsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BDCountsDto>><any>_observableThrow(response_);
        }));
    }

    protected processPostBDSearchInput(response: HttpResponseBase): Observable<BDCountsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BDCountsDto.fromJS(resultData200) : new BDCountsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BDCountsDto>(<any>null);
    }
}

@Injectable()
export class CarrierServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAllAsync(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<PagedResultDtoOfCarrierLineDto> {
        let url_ = this.baseUrl + "/api/services/app/Carrier/GetAllAsync?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAsync(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCarrierLineDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCarrierLineDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAsync(response: HttpResponseBase): Observable<PagedResultDtoOfCarrierLineDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCarrierLineDto.fromJS(resultData200) : new PagedResultDtoOfCarrierLineDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCarrierLineDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateTypes(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Carrier/UpdateTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTypes(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param isAllActive (optional) 
     * @return Success
     */
    updateAll(isAllActive: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Carrier/UpdateAll?";
        if (isAllActive !== undefined)
            url_ += "isAllActive=" + encodeURIComponent("" + isAllActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: CarrierLineDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Carrier/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCompanyTypes(): Observable<CommonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetCompanyTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyTypes(<any>response_);
                } catch (e) {
                    return <Observable<CommonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyTypes(response: HttpResponseBase): Observable<CommonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAMGList(): Observable<CommonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetAMGList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAMGList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAMGList(<any>response_);
                } catch (e) {
                    return <Observable<CommonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAMGList(response: HttpResponseBase): Observable<CommonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStates(): Observable<CommonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetStates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStates(<any>response_);
                } catch (e) {
                    return <Observable<CommonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStates(response: HttpResponseBase): Observable<CommonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCarriers(): Observable<CommonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetCarriers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCarriers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCarriers(<any>response_);
                } catch (e) {
                    return <Observable<CommonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCarriers(response: HttpResponseBase): Observable<CommonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAffiliations(): Observable<CommonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetAffiliations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliations(<any>response_);
                } catch (e) {
                    return <Observable<CommonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliations(response: HttpResponseBase): Observable<CommonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getContactTitles(): Observable<CommonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetContactTitles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactTitles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactTitles(<any>response_);
                } catch (e) {
                    return <Observable<CommonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactTitles(response: HttpResponseBase): Observable<CommonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProductLines(): Observable<CommonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetProductLines";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductLines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductLines(<any>response_);
                } catch (e) {
                    return <Observable<CommonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductLines(response: HttpResponseBase): Observable<CommonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDto[]>(<any>null);
    }

    /**
     * @param includedStates (optional) 
     * @param excludedStates (optional) 
     * @param isAdSearch (optional) 
     * @return Success
     */
    getCounties(includedStates: string | null | undefined, excludedStates: string | null | undefined, isAdSearch: boolean | null | undefined): Observable<CommonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetCounties?";
        if (includedStates !== undefined)
            url_ += "IncludedStates=" + encodeURIComponent("" + includedStates) + "&"; 
        if (excludedStates !== undefined)
            url_ += "ExcludedStates=" + encodeURIComponent("" + excludedStates) + "&"; 
        if (isAdSearch !== undefined)
            url_ += "isAdSearch=" + encodeURIComponent("" + isAdSearch) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCounties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCounties(<any>response_);
                } catch (e) {
                    return <Observable<CommonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCounties(response: HttpResponseBase): Observable<CommonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDto[]>(<any>null);
    }

    /**
     * @param includedStates (optional) 
     * @param excludedStates (optional) 
     * @return Success
     */
    getZipCodes(includedStates: string | null | undefined, excludedStates: string | null | undefined): Observable<ZipCodesDto> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetZipCodes?";
        if (includedStates !== undefined)
            url_ += "IncludedStates=" + encodeURIComponent("" + includedStates) + "&"; 
        if (excludedStates !== undefined)
            url_ += "ExcludedStates=" + encodeURIComponent("" + excludedStates) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZipCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZipCodes(<any>response_);
                } catch (e) {
                    return <Observable<ZipCodesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZipCodesDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetZipCodes(response: HttpResponseBase): Observable<ZipCodesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ZipCodesDto.fromJS(resultData200) : new ZipCodesDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZipCodesDto>(<any>null);
    }

    /**
     * @param includedStates (optional) 
     * @param excludedStates (optional) 
     * @return Success
     */
    getMetroAreas(includedStates: string | null | undefined, excludedStates: string | null | undefined): Observable<CommonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetMetroAreas?";
        if (includedStates !== undefined)
            url_ += "IncludedStates=" + encodeURIComponent("" + includedStates) + "&"; 
        if (excludedStates !== undefined)
            url_ += "ExcludedStates=" + encodeURIComponent("" + excludedStates) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMetroAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMetroAreas(<any>response_);
                } catch (e) {
                    return <Observable<CommonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMetroAreas(response: HttpResponseBase): Observable<CommonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDto[]>(<any>null);
    }

    /**
     * @param includedStates (optional) 
     * @param excludedStates (optional) 
     * @return Success
     */
    getAreas(includedStates: string | null | undefined, excludedStates: string | null | undefined): Observable<CommonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetAreas?";
        if (includedStates !== undefined)
            url_ += "IncludedStates=" + encodeURIComponent("" + includedStates) + "&"; 
        if (excludedStates !== undefined)
            url_ += "ExcludedStates=" + encodeURIComponent("" + excludedStates) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreas(<any>response_);
                } catch (e) {
                    return <Observable<CommonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreas(response: HttpResponseBase): Observable<CommonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getIndustries(): Observable<IndustryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetIndustries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndustries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndustries(<any>response_);
                } catch (e) {
                    return <Observable<IndustryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndustryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndustries(response: HttpResponseBase): Observable<IndustryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(IndustryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndustryDto[]>(<any>null);
    }
}

@Injectable()
export class CompanyTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAllAsync(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<PagedResultDtoOfCompanyTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyType/GetAllAsync?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAsync(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCompanyTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCompanyTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAsync(response: HttpResponseBase): Observable<PagedResultDtoOfCompanyTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCompanyTypeDto.fromJS(resultData200) : new PagedResultDtoOfCompanyTypeDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCompanyTypeDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateCompanyTypes(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CompanyType/UpdateCompanyTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompanyTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompanyTypes(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCompanyTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: CompanyTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CompanyType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param isAllActive (optional) 
     * @return Success
     */
    updateAll(isAllActive: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CompanyType/UpdateAll?";
        if (isAllActive !== undefined)
            url_ += "isAllActive=" + encodeURIComponent("" + isAllActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactTitleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAllAsync(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<PagedResultDtoOfContactTitleDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactTitle/GetAllAsync?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAsync(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactTitleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactTitleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAsync(response: HttpResponseBase): Observable<PagedResultDtoOfContactTitleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfContactTitleDto.fromJS(resultData200) : new PagedResultDtoOfContactTitleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContactTitleDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateTypes(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContactTitle/UpdateTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTypes(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: ContactTitleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContactTitle/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CustomerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateCustomerDto | null | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerDto.fromJS(resultData200) : new CustomerDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param roleId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomers(keyword: string | null | undefined, isActive: boolean | null | undefined, roleId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetAllCustomers?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomers(response: HttpResponseBase): Observable<PagedResultDtoOfUserProfileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserProfileDto.fromJS(resultData200) : new PagedResultDtoOfUserProfileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserProfileDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param roleId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getUsers(keyword: string | null | undefined, isActive: boolean | null | undefined, roleId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetUsers?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserProfileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserProfileDto.fromJS(resultData200) : new PagedResultDtoOfUserProfileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserProfileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerByUserid(id: number | null | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerByUserid?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerByUserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerByUserid(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerByUserid(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerDto.fromJS(resultData200) : new CustomerDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesperson(): Observable<SalespersonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetSalesperson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesperson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesperson(<any>response_);
                } catch (e) {
                    return <Observable<SalespersonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SalespersonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesperson(response: HttpResponseBase): Observable<SalespersonDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SalespersonDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalespersonDto[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param file (optional) 
     * @return Success
     */
    postImage(userId: number | null | undefined, file: FileParameter | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/PostImage?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostImage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmail(input: CustomerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerDto.fromJS(resultData200) : new CustomerDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfCustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCustomerDto.fromJS(resultData200) : new PagedResultDtoOfCustomerDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: CustomerDto | null | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerDto.fromJS(resultData200) : new CustomerDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmail(input: SendEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Email/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GeoLocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    updateGeoLocation(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GeoLocation/UpdateGeoLocation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeoLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeoLocation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGeoLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined): Observable<PagedResultDtoOfPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPaymentDto.fromJS(resultData200) : new PagedResultDtoOfPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaymentDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: PaymentInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param paymentRequest (optional) 
     * @return Success
     */
    checkOut(paymentRequest: PaymentRequestDto | null | undefined): Observable<KeyedSaleResponse> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CheckOut";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOut(<any>response_);
                } catch (e) {
                    return <Observable<KeyedSaleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<KeyedSaleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCheckOut(response: HttpResponseBase): Observable<KeyedSaleResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? KeyedSaleResponse.fromJS(resultData200) : new KeyedSaleResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KeyedSaleResponse>(<any>null);
    }
}

@Injectable()
export class PricingRuleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined): Observable<PagedResultDtoOfPricingRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/PricingRule/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPricingRuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPricingRuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfPricingRuleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPricingRuleDto.fromJS(resultData200) : new PagedResultDtoOfPricingRuleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPricingRuleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<PricingRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/PricingRule/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PricingRuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PricingRuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PricingRuleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PricingRuleDto.fromJS(resultData200) : new PricingRuleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PricingRuleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreatePricingRuleInput | null | undefined): Observable<PricingRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/PricingRule/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PricingRuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PricingRuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PricingRuleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PricingRuleDto.fromJS(resultData200) : new PricingRuleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PricingRuleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: PricingRuleDto | null | undefined): Observable<PricingRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/PricingRule/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PricingRuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PricingRuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PricingRuleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PricingRuleDto.fromJS(resultData200) : new PricingRuleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PricingRuleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PricingRule/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProductLineServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAllAsync(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<PagedResultDtoOfProductLineDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductLine/GetAllAsync?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAsync(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductLineDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductLineDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAsync(response: HttpResponseBase): Observable<PagedResultDtoOfProductLineDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfProductLineDto.fromJS(resultData200) : new PagedResultDtoOfProductLineDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductLineDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateTypes(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductLine/UpdateTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTypes(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: ProductLineDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductLine/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateRoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRolesAsync(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRolesAsync?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolesAsync(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: RoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRoleDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class SubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    getAllAsync(maxResultCount: number | null | undefined, skipCount: number | null | undefined, keyword: string | null | undefined): Observable<PagedResultDtoOfSubscriptionPlanDto> {
        let url_ = this.baseUrl + "/api/services/app/SubscriptionPlan/GetAllAsync?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAsync(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPlanDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPlanDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAsync(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPlanDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSubscriptionPlanDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPlanDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPlanDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAsync(id: number | null | undefined): Observable<SubscriptionPlanDto> {
        let url_ = this.baseUrl + "/api/services/app/SubscriptionPlan/GetAsync?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAsync(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAsync(response: HttpResponseBase): Observable<SubscriptionPlanDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPlanDto.fromJS(resultData200) : new SubscriptionPlanDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createAsync(input: CreateSubscriptionPlanInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SubscriptionPlan/CreateAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subscriptionPlan (optional) 
     * @return Success
     */
    update(subscriptionPlan: SubscriptionPlanDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SubscriptionPlan/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(subscriptionPlan);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SubscriptionPlan/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateTenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantDto.fromJS(resultData200) : new PagedResultDtoOfTenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: TenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    impersonate(id: number | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Impersonate?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateUserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: UserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<ListResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param roleId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, roleId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class PagedResultDtoOfADOrderDto implements IPagedResultDtoOfADOrderDto {
    totalCount: number | undefined;
    items: ADOrderDto[] | undefined;

    constructor(data?: IPagedResultDtoOfADOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ADOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfADOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfADOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfADOrderDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfADOrderDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfADOrderDto {
    totalCount: number | undefined;
    items: ADOrderDto[] | undefined;
}

export class ADOrderDto implements IADOrderDto {
    orderType: number | undefined;
    tranType: number | undefined;
    sUserId: string | undefined;
    description: string | undefined;
    recordCount: number | undefined;
    billFName: string | undefined;
    billLName: string | undefined;
    billCompany: string | undefined;
    billAddress: string | undefined;
    billCity: string | undefined;
    billState: string | undefined;
    billCountry: string | undefined;
    billZip: string | undefined;
    orderValue: number | undefined;
    typeField: string | undefined;
    typeCriteria: string | undefined;
    pVolume: string | undefined;
    empSize: string | undefined;
    pEmpCriteria: string | undefined;
    commPercent: string | undefined;
    agencyManagement: string | undefined;
    companyLines: string | undefined;
    country: string | undefined;
    state: string | undefined;
    county: string | undefined;
    sicCodes: string | undefined;
    accountIds: string | undefined;
    transactionID: string | undefined;
    active: boolean | undefined;
    isCtPurchased: boolean | undefined;
    ctCount: number | undefined;
    titleSearch: string | undefined;
    titleSearchCriteria: string | undefined;
    linesSearch: string | undefined;
    linesSearchCriteria: string | undefined;
    msa: string | undefined;
    orderNotes: string | undefined;
    cardNumber: string | undefined;
    achAccountName: string | undefined;
    achRouting: string | undefined;
    achAccount: string | undefined;
    achCheck: string | undefined;
    agencyMgntCriteria: string | undefined;
    affiliations: string | undefined;
    excludeState: string | undefined;
    excludeCountiesList: string | undefined;
    zip: string | undefined;
    excludeZip: string | undefined;
    areaCode: string | undefined;
    excludeAreaCode: string | undefined;
    excludeMSA: string | undefined;
    sicids: string | undefined;
    countyIDs: string | undefined;
    excludeCountyIds: string | undefined;
    revenueCriteria: string | undefined;
    revenueValue: string | undefined;
    queryID: number | undefined;
    overRideNotes: string | undefined;
    checkNo: string | undefined;
    salesUser: string | undefined;
    queryCriteria: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IADOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderType = data["orderType"];
            this.tranType = data["tranType"];
            this.sUserId = data["sUserId"];
            this.description = data["description"];
            this.recordCount = data["recordCount"];
            this.billFName = data["billFName"];
            this.billLName = data["billLName"];
            this.billCompany = data["billCompany"];
            this.billAddress = data["billAddress"];
            this.billCity = data["billCity"];
            this.billState = data["billState"];
            this.billCountry = data["billCountry"];
            this.billZip = data["billZip"];
            this.orderValue = data["orderValue"];
            this.typeField = data["typeField"];
            this.typeCriteria = data["typeCriteria"];
            this.pVolume = data["pVolume"];
            this.empSize = data["empSize"];
            this.pEmpCriteria = data["pEmpCriteria"];
            this.commPercent = data["commPercent"];
            this.agencyManagement = data["agencyManagement"];
            this.companyLines = data["companyLines"];
            this.country = data["country"];
            this.state = data["state"];
            this.county = data["county"];
            this.sicCodes = data["sicCodes"];
            this.accountIds = data["accountIds"];
            this.transactionID = data["transactionID"];
            this.active = data["active"];
            this.isCtPurchased = data["isCtPurchased"];
            this.ctCount = data["ctCount"];
            this.titleSearch = data["titleSearch"];
            this.titleSearchCriteria = data["titleSearchCriteria"];
            this.linesSearch = data["linesSearch"];
            this.linesSearchCriteria = data["linesSearchCriteria"];
            this.msa = data["msa"];
            this.orderNotes = data["orderNotes"];
            this.cardNumber = data["cardNumber"];
            this.achAccountName = data["achAccountName"];
            this.achRouting = data["achRouting"];
            this.achAccount = data["achAccount"];
            this.achCheck = data["achCheck"];
            this.agencyMgntCriteria = data["agencyMgntCriteria"];
            this.affiliations = data["affiliations"];
            this.excludeState = data["excludeState"];
            this.excludeCountiesList = data["excludeCountiesList"];
            this.zip = data["zip"];
            this.excludeZip = data["excludeZip"];
            this.areaCode = data["areaCode"];
            this.excludeAreaCode = data["excludeAreaCode"];
            this.excludeMSA = data["excludeMSA"];
            this.sicids = data["sicids"];
            this.countyIDs = data["countyIDs"];
            this.excludeCountyIds = data["excludeCountyIds"];
            this.revenueCriteria = data["revenueCriteria"];
            this.revenueValue = data["revenueValue"];
            this.queryID = data["queryID"];
            this.overRideNotes = data["overRideNotes"];
            this.checkNo = data["checkNo"];
            this.salesUser = data["salesUser"];
            this.queryCriteria = data["queryCriteria"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ADOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ADOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderType"] = this.orderType;
        data["tranType"] = this.tranType;
        data["sUserId"] = this.sUserId;
        data["description"] = this.description;
        data["recordCount"] = this.recordCount;
        data["billFName"] = this.billFName;
        data["billLName"] = this.billLName;
        data["billCompany"] = this.billCompany;
        data["billAddress"] = this.billAddress;
        data["billCity"] = this.billCity;
        data["billState"] = this.billState;
        data["billCountry"] = this.billCountry;
        data["billZip"] = this.billZip;
        data["orderValue"] = this.orderValue;
        data["typeField"] = this.typeField;
        data["typeCriteria"] = this.typeCriteria;
        data["pVolume"] = this.pVolume;
        data["empSize"] = this.empSize;
        data["pEmpCriteria"] = this.pEmpCriteria;
        data["commPercent"] = this.commPercent;
        data["agencyManagement"] = this.agencyManagement;
        data["companyLines"] = this.companyLines;
        data["country"] = this.country;
        data["state"] = this.state;
        data["county"] = this.county;
        data["sicCodes"] = this.sicCodes;
        data["accountIds"] = this.accountIds;
        data["transactionID"] = this.transactionID;
        data["active"] = this.active;
        data["isCtPurchased"] = this.isCtPurchased;
        data["ctCount"] = this.ctCount;
        data["titleSearch"] = this.titleSearch;
        data["titleSearchCriteria"] = this.titleSearchCriteria;
        data["linesSearch"] = this.linesSearch;
        data["linesSearchCriteria"] = this.linesSearchCriteria;
        data["msa"] = this.msa;
        data["orderNotes"] = this.orderNotes;
        data["cardNumber"] = this.cardNumber;
        data["achAccountName"] = this.achAccountName;
        data["achRouting"] = this.achRouting;
        data["achAccount"] = this.achAccount;
        data["achCheck"] = this.achCheck;
        data["agencyMgntCriteria"] = this.agencyMgntCriteria;
        data["affiliations"] = this.affiliations;
        data["excludeState"] = this.excludeState;
        data["excludeCountiesList"] = this.excludeCountiesList;
        data["zip"] = this.zip;
        data["excludeZip"] = this.excludeZip;
        data["areaCode"] = this.areaCode;
        data["excludeAreaCode"] = this.excludeAreaCode;
        data["excludeMSA"] = this.excludeMSA;
        data["sicids"] = this.sicids;
        data["countyIDs"] = this.countyIDs;
        data["excludeCountyIds"] = this.excludeCountyIds;
        data["revenueCriteria"] = this.revenueCriteria;
        data["revenueValue"] = this.revenueValue;
        data["queryID"] = this.queryID;
        data["overRideNotes"] = this.overRideNotes;
        data["checkNo"] = this.checkNo;
        data["salesUser"] = this.salesUser;
        data["queryCriteria"] = this.queryCriteria;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ADOrderDto {
        const json = this.toJSON();
        let result = new ADOrderDto();
        result.init(json);
        return result;
    }
}

export interface IADOrderDto {
    orderType: number | undefined;
    tranType: number | undefined;
    sUserId: string | undefined;
    description: string | undefined;
    recordCount: number | undefined;
    billFName: string | undefined;
    billLName: string | undefined;
    billCompany: string | undefined;
    billAddress: string | undefined;
    billCity: string | undefined;
    billState: string | undefined;
    billCountry: string | undefined;
    billZip: string | undefined;
    orderValue: number | undefined;
    typeField: string | undefined;
    typeCriteria: string | undefined;
    pVolume: string | undefined;
    empSize: string | undefined;
    pEmpCriteria: string | undefined;
    commPercent: string | undefined;
    agencyManagement: string | undefined;
    companyLines: string | undefined;
    country: string | undefined;
    state: string | undefined;
    county: string | undefined;
    sicCodes: string | undefined;
    accountIds: string | undefined;
    transactionID: string | undefined;
    active: boolean | undefined;
    isCtPurchased: boolean | undefined;
    ctCount: number | undefined;
    titleSearch: string | undefined;
    titleSearchCriteria: string | undefined;
    linesSearch: string | undefined;
    linesSearchCriteria: string | undefined;
    msa: string | undefined;
    orderNotes: string | undefined;
    cardNumber: string | undefined;
    achAccountName: string | undefined;
    achRouting: string | undefined;
    achAccount: string | undefined;
    achCheck: string | undefined;
    agencyMgntCriteria: string | undefined;
    affiliations: string | undefined;
    excludeState: string | undefined;
    excludeCountiesList: string | undefined;
    zip: string | undefined;
    excludeZip: string | undefined;
    areaCode: string | undefined;
    excludeAreaCode: string | undefined;
    excludeMSA: string | undefined;
    sicids: string | undefined;
    countyIDs: string | undefined;
    excludeCountyIds: string | undefined;
    revenueCriteria: string | undefined;
    revenueValue: string | undefined;
    queryID: number | undefined;
    overRideNotes: string | undefined;
    checkNo: string | undefined;
    salesUser: string | undefined;
    queryCriteria: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class AdReceiptDto implements IAdReceiptDto {
    neilson: CustomerDto | undefined;
    customer: CustomerDto | undefined;
    order: ADOrderDto | undefined;

    constructor(data?: IAdReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.neilson = data["neilson"] ? CustomerDto.fromJS(data["neilson"]) : <any>undefined;
            this.customer = data["customer"] ? CustomerDto.fromJS(data["customer"]) : <any>undefined;
            this.order = data["order"] ? ADOrderDto.fromJS(data["order"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["neilson"] = this.neilson ? this.neilson.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AdReceiptDto {
        const json = this.toJSON();
        let result = new AdReceiptDto();
        result.init(json);
        return result;
    }
}

export interface IAdReceiptDto {
    neilson: CustomerDto | undefined;
    customer: CustomerDto | undefined;
    order: ADOrderDto | undefined;
}

export class CustomerDto implements ICustomerDto {
    userId: number | undefined;
    fName: string;
    lName: string;
    companyName: string | undefined;
    address: string;
    city: string;
    state: string | undefined;
    country: string;
    zip: string;
    telephone: string;
    fax: string | undefined;
    mobile: string | undefined;
    email: string;
    web: string | undefined;
    billFName: string | undefined;
    billLName: string | undefined;
    billCompany: string | undefined;
    billAddress: string | undefined;
    billCity: string | undefined;
    billState: string | undefined;
    billCountry: string | undefined;
    billZip: string | undefined;
    active: boolean | undefined;
    suserid: string | undefined;
    adActiveDate: moment.Moment | undefined;
    adExpiresDate: moment.Moment | undefined;
    byPassCard: number | undefined;
    tcAgreed: boolean | undefined;
    tcDate: moment.Moment | undefined;
    bdActiveDate: moment.Moment | undefined;
    bdCredits: number | undefined;
    ccActiveDate: moment.Moment | undefined;
    ccExpiresDate: moment.Moment | undefined;
    ccAmount: number | undefined;
    subType: number | undefined;
    qUpdates: boolean | undefined;
    notes: string | undefined;
    agencyRec: number | undefined;
    agencyRecPrice: number | undefined;
    contactRec: number | undefined;
    contactRecPrice: number | undefined;
    imagePath: string | undefined;
    isSalesPerson: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.fName = data["fName"];
            this.lName = data["lName"];
            this.companyName = data["companyName"];
            this.address = data["address"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.zip = data["zip"];
            this.telephone = data["telephone"];
            this.fax = data["fax"];
            this.mobile = data["mobile"];
            this.email = data["email"];
            this.web = data["web"];
            this.billFName = data["billFName"];
            this.billLName = data["billLName"];
            this.billCompany = data["billCompany"];
            this.billAddress = data["billAddress"];
            this.billCity = data["billCity"];
            this.billState = data["billState"];
            this.billCountry = data["billCountry"];
            this.billZip = data["billZip"];
            this.active = data["active"];
            this.suserid = data["suserid"];
            this.adActiveDate = data["adActiveDate"] ? moment(data["adActiveDate"].toString()) : <any>undefined;
            this.adExpiresDate = data["adExpiresDate"] ? moment(data["adExpiresDate"].toString()) : <any>undefined;
            this.byPassCard = data["byPassCard"];
            this.tcAgreed = data["tcAgreed"];
            this.tcDate = data["tcDate"] ? moment(data["tcDate"].toString()) : <any>undefined;
            this.bdActiveDate = data["bdActiveDate"] ? moment(data["bdActiveDate"].toString()) : <any>undefined;
            this.bdCredits = data["bdCredits"];
            this.ccActiveDate = data["ccActiveDate"] ? moment(data["ccActiveDate"].toString()) : <any>undefined;
            this.ccExpiresDate = data["ccExpiresDate"] ? moment(data["ccExpiresDate"].toString()) : <any>undefined;
            this.ccAmount = data["ccAmount"];
            this.subType = data["subType"];
            this.qUpdates = data["qUpdates"];
            this.notes = data["notes"];
            this.agencyRec = data["agencyRec"];
            this.agencyRecPrice = data["agencyRecPrice"];
            this.contactRec = data["contactRec"];
            this.contactRecPrice = data["contactRecPrice"];
            this.imagePath = data["imagePath"];
            this.isSalesPerson = data["isSalesPerson"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["fName"] = this.fName;
        data["lName"] = this.lName;
        data["companyName"] = this.companyName;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zip"] = this.zip;
        data["telephone"] = this.telephone;
        data["fax"] = this.fax;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["web"] = this.web;
        data["billFName"] = this.billFName;
        data["billLName"] = this.billLName;
        data["billCompany"] = this.billCompany;
        data["billAddress"] = this.billAddress;
        data["billCity"] = this.billCity;
        data["billState"] = this.billState;
        data["billCountry"] = this.billCountry;
        data["billZip"] = this.billZip;
        data["active"] = this.active;
        data["suserid"] = this.suserid;
        data["adActiveDate"] = this.adActiveDate ? this.adActiveDate.toISOString() : <any>undefined;
        data["adExpiresDate"] = this.adExpiresDate ? this.adExpiresDate.toISOString() : <any>undefined;
        data["byPassCard"] = this.byPassCard;
        data["tcAgreed"] = this.tcAgreed;
        data["tcDate"] = this.tcDate ? this.tcDate.toISOString() : <any>undefined;
        data["bdActiveDate"] = this.bdActiveDate ? this.bdActiveDate.toISOString() : <any>undefined;
        data["bdCredits"] = this.bdCredits;
        data["ccActiveDate"] = this.ccActiveDate ? this.ccActiveDate.toISOString() : <any>undefined;
        data["ccExpiresDate"] = this.ccExpiresDate ? this.ccExpiresDate.toISOString() : <any>undefined;
        data["ccAmount"] = this.ccAmount;
        data["subType"] = this.subType;
        data["qUpdates"] = this.qUpdates;
        data["notes"] = this.notes;
        data["agencyRec"] = this.agencyRec;
        data["agencyRecPrice"] = this.agencyRecPrice;
        data["contactRec"] = this.contactRec;
        data["contactRecPrice"] = this.contactRecPrice;
        data["imagePath"] = this.imagePath;
        data["isSalesPerson"] = this.isSalesPerson;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CustomerDto {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto {
    userId: number | undefined;
    fName: string;
    lName: string;
    companyName: string | undefined;
    address: string;
    city: string;
    state: string | undefined;
    country: string;
    zip: string;
    telephone: string;
    fax: string | undefined;
    mobile: string | undefined;
    email: string;
    web: string | undefined;
    billFName: string | undefined;
    billLName: string | undefined;
    billCompany: string | undefined;
    billAddress: string | undefined;
    billCity: string | undefined;
    billState: string | undefined;
    billCountry: string | undefined;
    billZip: string | undefined;
    active: boolean | undefined;
    suserid: string | undefined;
    adActiveDate: moment.Moment | undefined;
    adExpiresDate: moment.Moment | undefined;
    byPassCard: number | undefined;
    tcAgreed: boolean | undefined;
    tcDate: moment.Moment | undefined;
    bdActiveDate: moment.Moment | undefined;
    bdCredits: number | undefined;
    ccActiveDate: moment.Moment | undefined;
    ccExpiresDate: moment.Moment | undefined;
    ccAmount: number | undefined;
    subType: number | undefined;
    qUpdates: boolean | undefined;
    notes: string | undefined;
    agencyRec: number | undefined;
    agencyRecPrice: number | undefined;
    contactRec: number | undefined;
    contactRecPrice: number | undefined;
    imagePath: string | undefined;
    isSalesPerson: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ADOrderInput implements IADOrderInput {
    orderType: ADOrderInputOrderType | undefined;
    tranType: number | undefined;
    sUserId: string | undefined;
    description: string | undefined;
    recordCount: number | undefined;
    billFName: string | undefined;
    billLName: string | undefined;
    billCompany: string | undefined;
    billAddress: string | undefined;
    billCity: string | undefined;
    billState: string | undefined;
    billCountry: string | undefined;
    billZip: string | undefined;
    orderValue: number | undefined;
    typeField: string | undefined;
    typeCriteria: string | undefined;
    pVolume: string | undefined;
    empSize: string | undefined;
    pEmpCriteria: string | undefined;
    commPercent: string | undefined;
    agencyManagement: string | undefined;
    companyLines: string | undefined;
    country: string | undefined;
    state: string | undefined;
    county: string | undefined;
    sicCodes: string | undefined;
    accountIds: string | undefined;
    transactionID: string | undefined;
    active: boolean | undefined;
    isCtPurchased: boolean | undefined;
    ctCount: number | undefined;
    titleSearch: string | undefined;
    titleSearchCriteria: string | undefined;
    linesSearch: string | undefined;
    linesSearchCriteria: string | undefined;
    msa: string | undefined;
    orderNotes: string | undefined;
    cardNumber: string | undefined;
    achAccountName: string | undefined;
    achRouting: string | undefined;
    achAccount: string | undefined;
    achCheck: string | undefined;
    agencyMgntCriteria: string | undefined;
    affiliations: string | undefined;
    excludeState: string | undefined;
    excludeCountiesList: string | undefined;
    zip: string | undefined;
    excludeZip: string | undefined;
    areaCode: string | undefined;
    excludeAreaCode: string | undefined;
    excludeMSA: string | undefined;
    sicids: string | undefined;
    countyIDs: string | undefined;
    excludeCountyIds: string | undefined;
    revenueCriteria: string | undefined;
    revenueValue: string | undefined;
    queryID: number | undefined;
    overRideNotes: string | undefined;
    checkNo: string | undefined;
    salesUser: string | undefined;
    queryCriteria: string | undefined;

    constructor(data?: IADOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderType = data["orderType"];
            this.tranType = data["tranType"];
            this.sUserId = data["sUserId"];
            this.description = data["description"];
            this.recordCount = data["recordCount"];
            this.billFName = data["billFName"];
            this.billLName = data["billLName"];
            this.billCompany = data["billCompany"];
            this.billAddress = data["billAddress"];
            this.billCity = data["billCity"];
            this.billState = data["billState"];
            this.billCountry = data["billCountry"];
            this.billZip = data["billZip"];
            this.orderValue = data["orderValue"];
            this.typeField = data["typeField"];
            this.typeCriteria = data["typeCriteria"];
            this.pVolume = data["pVolume"];
            this.empSize = data["empSize"];
            this.pEmpCriteria = data["pEmpCriteria"];
            this.commPercent = data["commPercent"];
            this.agencyManagement = data["agencyManagement"];
            this.companyLines = data["companyLines"];
            this.country = data["country"];
            this.state = data["state"];
            this.county = data["county"];
            this.sicCodes = data["sicCodes"];
            this.accountIds = data["accountIds"];
            this.transactionID = data["transactionID"];
            this.active = data["active"];
            this.isCtPurchased = data["isCtPurchased"];
            this.ctCount = data["ctCount"];
            this.titleSearch = data["titleSearch"];
            this.titleSearchCriteria = data["titleSearchCriteria"];
            this.linesSearch = data["linesSearch"];
            this.linesSearchCriteria = data["linesSearchCriteria"];
            this.msa = data["msa"];
            this.orderNotes = data["orderNotes"];
            this.cardNumber = data["cardNumber"];
            this.achAccountName = data["achAccountName"];
            this.achRouting = data["achRouting"];
            this.achAccount = data["achAccount"];
            this.achCheck = data["achCheck"];
            this.agencyMgntCriteria = data["agencyMgntCriteria"];
            this.affiliations = data["affiliations"];
            this.excludeState = data["excludeState"];
            this.excludeCountiesList = data["excludeCountiesList"];
            this.zip = data["zip"];
            this.excludeZip = data["excludeZip"];
            this.areaCode = data["areaCode"];
            this.excludeAreaCode = data["excludeAreaCode"];
            this.excludeMSA = data["excludeMSA"];
            this.sicids = data["sicids"];
            this.countyIDs = data["countyIDs"];
            this.excludeCountyIds = data["excludeCountyIds"];
            this.revenueCriteria = data["revenueCriteria"];
            this.revenueValue = data["revenueValue"];
            this.queryID = data["queryID"];
            this.overRideNotes = data["overRideNotes"];
            this.checkNo = data["checkNo"];
            this.salesUser = data["salesUser"];
            this.queryCriteria = data["queryCriteria"];
        }
    }

    static fromJS(data: any): ADOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new ADOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderType"] = this.orderType;
        data["tranType"] = this.tranType;
        data["sUserId"] = this.sUserId;
        data["description"] = this.description;
        data["recordCount"] = this.recordCount;
        data["billFName"] = this.billFName;
        data["billLName"] = this.billLName;
        data["billCompany"] = this.billCompany;
        data["billAddress"] = this.billAddress;
        data["billCity"] = this.billCity;
        data["billState"] = this.billState;
        data["billCountry"] = this.billCountry;
        data["billZip"] = this.billZip;
        data["orderValue"] = this.orderValue;
        data["typeField"] = this.typeField;
        data["typeCriteria"] = this.typeCriteria;
        data["pVolume"] = this.pVolume;
        data["empSize"] = this.empSize;
        data["pEmpCriteria"] = this.pEmpCriteria;
        data["commPercent"] = this.commPercent;
        data["agencyManagement"] = this.agencyManagement;
        data["companyLines"] = this.companyLines;
        data["country"] = this.country;
        data["state"] = this.state;
        data["county"] = this.county;
        data["sicCodes"] = this.sicCodes;
        data["accountIds"] = this.accountIds;
        data["transactionID"] = this.transactionID;
        data["active"] = this.active;
        data["isCtPurchased"] = this.isCtPurchased;
        data["ctCount"] = this.ctCount;
        data["titleSearch"] = this.titleSearch;
        data["titleSearchCriteria"] = this.titleSearchCriteria;
        data["linesSearch"] = this.linesSearch;
        data["linesSearchCriteria"] = this.linesSearchCriteria;
        data["msa"] = this.msa;
        data["orderNotes"] = this.orderNotes;
        data["cardNumber"] = this.cardNumber;
        data["achAccountName"] = this.achAccountName;
        data["achRouting"] = this.achRouting;
        data["achAccount"] = this.achAccount;
        data["achCheck"] = this.achCheck;
        data["agencyMgntCriteria"] = this.agencyMgntCriteria;
        data["affiliations"] = this.affiliations;
        data["excludeState"] = this.excludeState;
        data["excludeCountiesList"] = this.excludeCountiesList;
        data["zip"] = this.zip;
        data["excludeZip"] = this.excludeZip;
        data["areaCode"] = this.areaCode;
        data["excludeAreaCode"] = this.excludeAreaCode;
        data["excludeMSA"] = this.excludeMSA;
        data["sicids"] = this.sicids;
        data["countyIDs"] = this.countyIDs;
        data["excludeCountyIds"] = this.excludeCountyIds;
        data["revenueCriteria"] = this.revenueCriteria;
        data["revenueValue"] = this.revenueValue;
        data["queryID"] = this.queryID;
        data["overRideNotes"] = this.overRideNotes;
        data["checkNo"] = this.checkNo;
        data["salesUser"] = this.salesUser;
        data["queryCriteria"] = this.queryCriteria;
        return data; 
    }

    clone(): ADOrderInput {
        const json = this.toJSON();
        let result = new ADOrderInput();
        result.init(json);
        return result;
    }
}

export interface IADOrderInput {
    orderType: ADOrderInputOrderType | undefined;
    tranType: number | undefined;
    sUserId: string | undefined;
    description: string | undefined;
    recordCount: number | undefined;
    billFName: string | undefined;
    billLName: string | undefined;
    billCompany: string | undefined;
    billAddress: string | undefined;
    billCity: string | undefined;
    billState: string | undefined;
    billCountry: string | undefined;
    billZip: string | undefined;
    orderValue: number | undefined;
    typeField: string | undefined;
    typeCriteria: string | undefined;
    pVolume: string | undefined;
    empSize: string | undefined;
    pEmpCriteria: string | undefined;
    commPercent: string | undefined;
    agencyManagement: string | undefined;
    companyLines: string | undefined;
    country: string | undefined;
    state: string | undefined;
    county: string | undefined;
    sicCodes: string | undefined;
    accountIds: string | undefined;
    transactionID: string | undefined;
    active: boolean | undefined;
    isCtPurchased: boolean | undefined;
    ctCount: number | undefined;
    titleSearch: string | undefined;
    titleSearchCriteria: string | undefined;
    linesSearch: string | undefined;
    linesSearchCriteria: string | undefined;
    msa: string | undefined;
    orderNotes: string | undefined;
    cardNumber: string | undefined;
    achAccountName: string | undefined;
    achRouting: string | undefined;
    achAccount: string | undefined;
    achCheck: string | undefined;
    agencyMgntCriteria: string | undefined;
    affiliations: string | undefined;
    excludeState: string | undefined;
    excludeCountiesList: string | undefined;
    zip: string | undefined;
    excludeZip: string | undefined;
    areaCode: string | undefined;
    excludeAreaCode: string | undefined;
    excludeMSA: string | undefined;
    sicids: string | undefined;
    countyIDs: string | undefined;
    excludeCountyIds: string | undefined;
    revenueCriteria: string | undefined;
    revenueValue: string | undefined;
    queryID: number | undefined;
    overRideNotes: string | undefined;
    checkNo: string | undefined;
    salesUser: string | undefined;
    queryCriteria: string | undefined;
}

export class JSonResultDto implements IJSonResultDto {
    status: JSonResultDtoStatus | undefined;
    data: string | undefined;

    constructor(data?: IJSonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.data = data["data"];
        }
    }

    static fromJS(data: any): JSonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new JSonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["data"] = this.data;
        return data; 
    }

    clone(): JSonResultDto {
        const json = this.toJSON();
        let result = new JSonResultDto();
        result.init(json);
        return result;
    }
}

export interface IJSonResultDto {
    status: JSonResultDtoStatus | undefined;
    data: string | undefined;
}

export class AccountDto implements IAccountDto {
    agencyDetails: AgencyDto | undefined;
    targetSectors: TargetSectorDto[] | undefined;
    specialAffiliations: AffiliationDto[] | undefined;
    carriers: CarrierDto[] | undefined;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.agencyDetails = data["agencyDetails"] ? AgencyDto.fromJS(data["agencyDetails"]) : <any>undefined;
            if (data["targetSectors"] && data["targetSectors"].constructor === Array) {
                this.targetSectors = [];
                for (let item of data["targetSectors"])
                    this.targetSectors.push(TargetSectorDto.fromJS(item));
            }
            if (data["specialAffiliations"] && data["specialAffiliations"].constructor === Array) {
                this.specialAffiliations = [];
                for (let item of data["specialAffiliations"])
                    this.specialAffiliations.push(AffiliationDto.fromJS(item));
            }
            if (data["carriers"] && data["carriers"].constructor === Array) {
                this.carriers = [];
                for (let item of data["carriers"])
                    this.carriers.push(CarrierDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agencyDetails"] = this.agencyDetails ? this.agencyDetails.toJSON() : <any>undefined;
        if (this.targetSectors && this.targetSectors.constructor === Array) {
            data["targetSectors"] = [];
            for (let item of this.targetSectors)
                data["targetSectors"].push(item.toJSON());
        }
        if (this.specialAffiliations && this.specialAffiliations.constructor === Array) {
            data["specialAffiliations"] = [];
            for (let item of this.specialAffiliations)
                data["specialAffiliations"].push(item.toJSON());
        }
        if (this.carriers && this.carriers.constructor === Array) {
            data["carriers"] = [];
            for (let item of this.carriers)
                data["carriers"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AccountDto {
        const json = this.toJSON();
        let result = new AccountDto();
        result.init(json);
        return result;
    }
}

export interface IAccountDto {
    agencyDetails: AgencyDto | undefined;
    targetSectors: TargetSectorDto[] | undefined;
    specialAffiliations: AffiliationDto[] | undefined;
    carriers: CarrierDto[] | undefined;
}

export class AgencyDto implements IAgencyDto {
    account: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    county: string | undefined;
    timeZone: string | undefined;
    country: string | undefined;
    division: string | undefined;
    mainPhone: string | undefined;
    phoneExtension: string | undefined;
    fax: string | undefined;
    tollFree: string | undefined;
    webAddress: string | undefined;
    email: string | undefined;
    type: string | undefined;
    revenue: number | undefined;
    percentComm: number | undefined;
    employees: number | undefined;
    specialAffiliation: string | undefined;
    agencyManagement: string | undefined;
    producer: string | undefined;
    lastName: string | undefined;
    firstName: string | undefined;
    suffix: string | undefined;
    title: string | undefined;
    mobile: string | undefined;
    cEmail: string | undefined;
    accountId: string | undefined;
    spLines: string | undefined;
    titleSearch: string | undefined;
    lineSearch: string | undefined;
    msa: string | undefined;
    premiumVolume: number | undefined;
    dunsNum: string | undefined;
    cEmail2: string | undefined;
    linkedUrl: string | undefined;
    branchIndicator: string | undefined;
    num_Locations: number | undefined;
    twitterUrl: string | undefined;
    facebookUrl: string | undefined;
    googleplusUrl: string | undefined;
    youtubeUrl: string | undefined;
    linkedin: string | undefined;
    countyCode: string | undefined;
    cTwitterUrl: string | undefined;
    cFacebookUrl: string | undefined;
    cGoogleplusUrl: string | undefined;
    cYoutubeUrl: string | undefined;
    longitude: number | undefined;
    latitude: number | undefined;
    geoCodeStatus: number | undefined;
    id: number | undefined;

    constructor(data?: IAgencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.account = data["account"];
            this.address1 = data["address1"];
            this.address2 = data["address2"];
            this.city = data["city"];
            this.state = data["state"];
            this.postalCode = data["postalCode"];
            this.county = data["county"];
            this.timeZone = data["timeZone"];
            this.country = data["country"];
            this.division = data["division"];
            this.mainPhone = data["mainPhone"];
            this.phoneExtension = data["phoneExtension"];
            this.fax = data["fax"];
            this.tollFree = data["tollFree"];
            this.webAddress = data["webAddress"];
            this.email = data["email"];
            this.type = data["type"];
            this.revenue = data["revenue"];
            this.percentComm = data["percentComm"];
            this.employees = data["employees"];
            this.specialAffiliation = data["specialAffiliation"];
            this.agencyManagement = data["agencyManagement"];
            this.producer = data["producer"];
            this.lastName = data["lastName"];
            this.firstName = data["firstName"];
            this.suffix = data["suffix"];
            this.title = data["title"];
            this.mobile = data["mobile"];
            this.cEmail = data["cEmail"];
            this.accountId = data["accountId"];
            this.spLines = data["spLines"];
            this.titleSearch = data["titleSearch"];
            this.lineSearch = data["lineSearch"];
            this.msa = data["msa"];
            this.premiumVolume = data["premiumVolume"];
            this.dunsNum = data["dunsNum"];
            this.cEmail2 = data["cEmail2"];
            this.linkedUrl = data["linkedUrl"];
            this.branchIndicator = data["branchIndicator"];
            this.num_Locations = data["num_Locations"];
            this.twitterUrl = data["twitterUrl"];
            this.facebookUrl = data["facebookUrl"];
            this.googleplusUrl = data["googleplusUrl"];
            this.youtubeUrl = data["youtubeUrl"];
            this.linkedin = data["linkedin"];
            this.countyCode = data["countyCode"];
            this.cTwitterUrl = data["cTwitterUrl"];
            this.cFacebookUrl = data["cFacebookUrl"];
            this.cGoogleplusUrl = data["cGoogleplusUrl"];
            this.cYoutubeUrl = data["cYoutubeUrl"];
            this.longitude = data["longitude"];
            this.latitude = data["latitude"];
            this.geoCodeStatus = data["geoCodeStatus"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AgencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["county"] = this.county;
        data["timeZone"] = this.timeZone;
        data["country"] = this.country;
        data["division"] = this.division;
        data["mainPhone"] = this.mainPhone;
        data["phoneExtension"] = this.phoneExtension;
        data["fax"] = this.fax;
        data["tollFree"] = this.tollFree;
        data["webAddress"] = this.webAddress;
        data["email"] = this.email;
        data["type"] = this.type;
        data["revenue"] = this.revenue;
        data["percentComm"] = this.percentComm;
        data["employees"] = this.employees;
        data["specialAffiliation"] = this.specialAffiliation;
        data["agencyManagement"] = this.agencyManagement;
        data["producer"] = this.producer;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["suffix"] = this.suffix;
        data["title"] = this.title;
        data["mobile"] = this.mobile;
        data["cEmail"] = this.cEmail;
        data["accountId"] = this.accountId;
        data["spLines"] = this.spLines;
        data["titleSearch"] = this.titleSearch;
        data["lineSearch"] = this.lineSearch;
        data["msa"] = this.msa;
        data["premiumVolume"] = this.premiumVolume;
        data["dunsNum"] = this.dunsNum;
        data["cEmail2"] = this.cEmail2;
        data["linkedUrl"] = this.linkedUrl;
        data["branchIndicator"] = this.branchIndicator;
        data["num_Locations"] = this.num_Locations;
        data["twitterUrl"] = this.twitterUrl;
        data["facebookUrl"] = this.facebookUrl;
        data["googleplusUrl"] = this.googleplusUrl;
        data["youtubeUrl"] = this.youtubeUrl;
        data["linkedin"] = this.linkedin;
        data["countyCode"] = this.countyCode;
        data["cTwitterUrl"] = this.cTwitterUrl;
        data["cFacebookUrl"] = this.cFacebookUrl;
        data["cGoogleplusUrl"] = this.cGoogleplusUrl;
        data["cYoutubeUrl"] = this.cYoutubeUrl;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["geoCodeStatus"] = this.geoCodeStatus;
        data["id"] = this.id;
        return data; 
    }

    clone(): AgencyDto {
        const json = this.toJSON();
        let result = new AgencyDto();
        result.init(json);
        return result;
    }
}

export interface IAgencyDto {
    account: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    county: string | undefined;
    timeZone: string | undefined;
    country: string | undefined;
    division: string | undefined;
    mainPhone: string | undefined;
    phoneExtension: string | undefined;
    fax: string | undefined;
    tollFree: string | undefined;
    webAddress: string | undefined;
    email: string | undefined;
    type: string | undefined;
    revenue: number | undefined;
    percentComm: number | undefined;
    employees: number | undefined;
    specialAffiliation: string | undefined;
    agencyManagement: string | undefined;
    producer: string | undefined;
    lastName: string | undefined;
    firstName: string | undefined;
    suffix: string | undefined;
    title: string | undefined;
    mobile: string | undefined;
    cEmail: string | undefined;
    accountId: string | undefined;
    spLines: string | undefined;
    titleSearch: string | undefined;
    lineSearch: string | undefined;
    msa: string | undefined;
    premiumVolume: number | undefined;
    dunsNum: string | undefined;
    cEmail2: string | undefined;
    linkedUrl: string | undefined;
    branchIndicator: string | undefined;
    num_Locations: number | undefined;
    twitterUrl: string | undefined;
    facebookUrl: string | undefined;
    googleplusUrl: string | undefined;
    youtubeUrl: string | undefined;
    linkedin: string | undefined;
    countyCode: string | undefined;
    cTwitterUrl: string | undefined;
    cFacebookUrl: string | undefined;
    cGoogleplusUrl: string | undefined;
    cYoutubeUrl: string | undefined;
    longitude: number | undefined;
    latitude: number | undefined;
    geoCodeStatus: number | undefined;
    id: number | undefined;
}

export class TargetSectorDto implements ITargetSectorDto {
    accountId: string | undefined;
    account: string | undefined;
    sicCode: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: ITargetSectorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.account = data["account"];
            this.sicCode = data["sicCode"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TargetSectorDto {
        data = typeof data === 'object' ? data : {};
        let result = new TargetSectorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["account"] = this.account;
        data["sicCode"] = this.sicCode;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): TargetSectorDto {
        const json = this.toJSON();
        let result = new TargetSectorDto();
        result.init(json);
        return result;
    }
}

export interface ITargetSectorDto {
    accountId: string | undefined;
    account: string | undefined;
    sicCode: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class AffiliationDto implements IAffiliationDto {
    accountId: string | undefined;
    account: string | undefined;
    specialAffiliation: string | undefined;
    id: number | undefined;

    constructor(data?: IAffiliationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.account = data["account"];
            this.specialAffiliation = data["specialAffiliation"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AffiliationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AffiliationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["account"] = this.account;
        data["specialAffiliation"] = this.specialAffiliation;
        data["id"] = this.id;
        return data; 
    }

    clone(): AffiliationDto {
        const json = this.toJSON();
        let result = new AffiliationDto();
        result.init(json);
        return result;
    }
}

export interface IAffiliationDto {
    accountId: string | undefined;
    account: string | undefined;
    specialAffiliation: string | undefined;
    id: number | undefined;
}

export class CarrierDto implements ICarrierDto {
    accountId: string | undefined;
    account: string | undefined;
    companyLine: string | undefined;
    id: number | undefined;

    constructor(data?: ICarrierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.account = data["account"];
            this.companyLine = data["companyLine"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CarrierDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarrierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["account"] = this.account;
        data["companyLine"] = this.companyLine;
        data["id"] = this.id;
        return data; 
    }

    clone(): CarrierDto {
        const json = this.toJSON();
        let result = new CarrierDto();
        result.init(json);
        return result;
    }
}

export interface ICarrierDto {
    accountId: string | undefined;
    account: string | undefined;
    companyLine: string | undefined;
    id: number | undefined;
}

export class AdOrderMailInput implements IAdOrderMailInput {
    orderId: number | undefined;
    description: string | undefined;
    orderDate: moment.Moment | undefined;
    salesUser: string | undefined;
    recordCount: number | undefined;
    ctCount: number | undefined;
    customerName: string | undefined;
    paymentType: string | undefined;
    checkNo: string | undefined;
    cardNumber: string | undefined;
    orderValue: number | undefined;
    targetUser: string | undefined;

    constructor(data?: IAdOrderMailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.description = data["description"];
            this.orderDate = data["orderDate"] ? moment(data["orderDate"].toString()) : <any>undefined;
            this.salesUser = data["salesUser"];
            this.recordCount = data["recordCount"];
            this.ctCount = data["ctCount"];
            this.customerName = data["customerName"];
            this.paymentType = data["paymentType"];
            this.checkNo = data["checkNo"];
            this.cardNumber = data["cardNumber"];
            this.orderValue = data["orderValue"];
            this.targetUser = data["targetUser"];
        }
    }

    static fromJS(data: any): AdOrderMailInput {
        data = typeof data === 'object' ? data : {};
        let result = new AdOrderMailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["description"] = this.description;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["salesUser"] = this.salesUser;
        data["recordCount"] = this.recordCount;
        data["ctCount"] = this.ctCount;
        data["customerName"] = this.customerName;
        data["paymentType"] = this.paymentType;
        data["checkNo"] = this.checkNo;
        data["cardNumber"] = this.cardNumber;
        data["orderValue"] = this.orderValue;
        data["targetUser"] = this.targetUser;
        return data; 
    }

    clone(): AdOrderMailInput {
        const json = this.toJSON();
        let result = new AdOrderMailInput();
        result.init(json);
        return result;
    }
}

export interface IAdOrderMailInput {
    orderId: number | undefined;
    description: string | undefined;
    orderDate: moment.Moment | undefined;
    salesUser: string | undefined;
    recordCount: number | undefined;
    ctCount: number | undefined;
    customerName: string | undefined;
    paymentType: string | undefined;
    checkNo: string | undefined;
    cardNumber: string | undefined;
    orderValue: number | undefined;
    targetUser: string | undefined;
}

export class PagedResultDtoOfADSearchDto implements IPagedResultDtoOfADSearchDto {
    totalCount: number | undefined;
    items: ADSearchDto[] | undefined;

    constructor(data?: IPagedResultDtoOfADSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ADSearchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfADSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfADSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfADSearchDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfADSearchDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfADSearchDto {
    totalCount: number | undefined;
    items: ADSearchDto[] | undefined;
}

export class ADSearchDto implements IADSearchDto {
    queryName: string | undefined;
    typeField: string | undefined;
    typeCriteria: string | undefined;
    pVolume: string | undefined;
    empSize: string | undefined;
    pEmpCriteria: string | undefined;
    commPercent: string | undefined;
    agencyManagement: string | undefined;
    agencyMgntCriteria: string | undefined;
    companyLines: string | undefined;
    country: string | undefined;
    state: string | undefined;
    county: string | undefined;
    sicCodes: string | undefined;
    active: boolean | undefined;
    titleSearch: string | undefined;
    titleSearchCriteria: string | undefined;
    linesSearch: string | undefined;
    linesSearchCriteria: string | undefined;
    msa: string | undefined;
    msaConcatenated: string | undefined;
    countyConcatenated: string | undefined;
    affiliations: string | undefined;
    excludeState: string | undefined;
    excludeCountiesList: string | undefined;
    zip: string | undefined;
    excludeZip: string | undefined;
    areaCode: string | undefined;
    excludeAreaCode: string | undefined;
    excludeMSA: string | undefined;
    sicids: string | undefined;
    countyIDs: string | undefined;
    excludeCountyIds: string | undefined;
    revenueCriteria: string | undefined;
    revenueValue: string | undefined;
    queryCriteria: string | undefined;
    companyName: string | undefined;
    companyNameType: string | undefined;
    minorityOwned: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IADSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.queryName = data["queryName"];
            this.typeField = data["typeField"];
            this.typeCriteria = data["typeCriteria"];
            this.pVolume = data["pVolume"];
            this.empSize = data["empSize"];
            this.pEmpCriteria = data["pEmpCriteria"];
            this.commPercent = data["commPercent"];
            this.agencyManagement = data["agencyManagement"];
            this.agencyMgntCriteria = data["agencyMgntCriteria"];
            this.companyLines = data["companyLines"];
            this.country = data["country"];
            this.state = data["state"];
            this.county = data["county"];
            this.sicCodes = data["sicCodes"];
            this.active = data["active"];
            this.titleSearch = data["titleSearch"];
            this.titleSearchCriteria = data["titleSearchCriteria"];
            this.linesSearch = data["linesSearch"];
            this.linesSearchCriteria = data["linesSearchCriteria"];
            this.msa = data["msa"];
            this.msaConcatenated = data["msaConcatenated"];
            this.countyConcatenated = data["countyConcatenated"];
            this.affiliations = data["affiliations"];
            this.excludeState = data["excludeState"];
            this.excludeCountiesList = data["excludeCountiesList"];
            this.zip = data["zip"];
            this.excludeZip = data["excludeZip"];
            this.areaCode = data["areaCode"];
            this.excludeAreaCode = data["excludeAreaCode"];
            this.excludeMSA = data["excludeMSA"];
            this.sicids = data["sicids"];
            this.countyIDs = data["countyIDs"];
            this.excludeCountyIds = data["excludeCountyIds"];
            this.revenueCriteria = data["revenueCriteria"];
            this.revenueValue = data["revenueValue"];
            this.queryCriteria = data["queryCriteria"];
            this.companyName = data["companyName"];
            this.companyNameType = data["companyNameType"];
            this.minorityOwned = data["minorityOwned"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ADSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ADSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryName"] = this.queryName;
        data["typeField"] = this.typeField;
        data["typeCriteria"] = this.typeCriteria;
        data["pVolume"] = this.pVolume;
        data["empSize"] = this.empSize;
        data["pEmpCriteria"] = this.pEmpCriteria;
        data["commPercent"] = this.commPercent;
        data["agencyManagement"] = this.agencyManagement;
        data["agencyMgntCriteria"] = this.agencyMgntCriteria;
        data["companyLines"] = this.companyLines;
        data["country"] = this.country;
        data["state"] = this.state;
        data["county"] = this.county;
        data["sicCodes"] = this.sicCodes;
        data["active"] = this.active;
        data["titleSearch"] = this.titleSearch;
        data["titleSearchCriteria"] = this.titleSearchCriteria;
        data["linesSearch"] = this.linesSearch;
        data["linesSearchCriteria"] = this.linesSearchCriteria;
        data["msa"] = this.msa;
        data["msaConcatenated"] = this.msaConcatenated;
        data["countyConcatenated"] = this.countyConcatenated;
        data["affiliations"] = this.affiliations;
        data["excludeState"] = this.excludeState;
        data["excludeCountiesList"] = this.excludeCountiesList;
        data["zip"] = this.zip;
        data["excludeZip"] = this.excludeZip;
        data["areaCode"] = this.areaCode;
        data["excludeAreaCode"] = this.excludeAreaCode;
        data["excludeMSA"] = this.excludeMSA;
        data["sicids"] = this.sicids;
        data["countyIDs"] = this.countyIDs;
        data["excludeCountyIds"] = this.excludeCountyIds;
        data["revenueCriteria"] = this.revenueCriteria;
        data["revenueValue"] = this.revenueValue;
        data["queryCriteria"] = this.queryCriteria;
        data["companyName"] = this.companyName;
        data["companyNameType"] = this.companyNameType;
        data["minorityOwned"] = this.minorityOwned;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ADSearchDto {
        const json = this.toJSON();
        let result = new ADSearchDto();
        result.init(json);
        return result;
    }
}

export interface IADSearchDto {
    queryName: string | undefined;
    typeField: string | undefined;
    typeCriteria: string | undefined;
    pVolume: string | undefined;
    empSize: string | undefined;
    pEmpCriteria: string | undefined;
    commPercent: string | undefined;
    agencyManagement: string | undefined;
    agencyMgntCriteria: string | undefined;
    companyLines: string | undefined;
    country: string | undefined;
    state: string | undefined;
    county: string | undefined;
    sicCodes: string | undefined;
    active: boolean | undefined;
    titleSearch: string | undefined;
    titleSearchCriteria: string | undefined;
    linesSearch: string | undefined;
    linesSearchCriteria: string | undefined;
    msa: string | undefined;
    msaConcatenated: string | undefined;
    countyConcatenated: string | undefined;
    affiliations: string | undefined;
    excludeState: string | undefined;
    excludeCountiesList: string | undefined;
    zip: string | undefined;
    excludeZip: string | undefined;
    areaCode: string | undefined;
    excludeAreaCode: string | undefined;
    excludeMSA: string | undefined;
    sicids: string | undefined;
    countyIDs: string | undefined;
    excludeCountyIds: string | undefined;
    revenueCriteria: string | undefined;
    revenueValue: string | undefined;
    queryCriteria: string | undefined;
    companyName: string | undefined;
    companyNameType: string | undefined;
    minorityOwned: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ADSearchInput implements IADSearchInput {
    queryCriteria: string | undefined;
    queryName: string | undefined;
    affiliations: string | undefined;
    agencyManagement: string | undefined;
    agencyMgntCriteria: string | undefined;
    areaCode: string | undefined;
    commPercent: string | undefined;
    companyLines: string | undefined;
    companyName: string | undefined;
    companyNameType: string | undefined;
    country: string | undefined;
    county: string | undefined;
    countyConcatenated: string | undefined;
    countyIDs: string | undefined;
    empSize: string | undefined;
    excludeAreaCode: string | undefined;
    excludeCountiesList: string | undefined;
    excludeCountyIds: string | undefined;
    excludeMSA: string | undefined;
    excludeState: string | undefined;
    excludeZip: string | undefined;
    includeCountyIds: string | undefined;
    linesSearch: string | undefined;
    linesSearchCriteria: string | undefined;
    msa: string | undefined;
    msaConcatenated: string | undefined;
    pEmpCriteria: string | undefined;
    pVolume: string | undefined;
    revenueCriteria: string | undefined;
    revenueValue: string | undefined;
    sicCodes: string | undefined;
    sicids: string | undefined;
    state: string | undefined;
    titleSearch: string | undefined;
    titleSearchCriteria: string | undefined;
    typeCriteria: string | undefined;
    typeField: string | undefined;
    zip: string | undefined;
    isRetail: boolean | undefined;
    isWholesale: boolean | undefined;
    minorityOwned: string | undefined;
    carrierManageCrieteria: string | undefined;

    constructor(data?: IADSearchInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.queryCriteria = data["queryCriteria"];
            this.queryName = data["queryName"];
            this.affiliations = data["affiliations"];
            this.agencyManagement = data["agencyManagement"];
            this.agencyMgntCriteria = data["agencyMgntCriteria"];
            this.areaCode = data["areaCode"];
            this.commPercent = data["commPercent"];
            this.companyLines = data["companyLines"];
            this.companyName = data["companyName"];
            this.companyNameType = data["companyNameType"];
            this.country = data["country"];
            this.county = data["county"];
            this.countyConcatenated = data["countyConcatenated"];
            this.countyIDs = data["countyIDs"];
            this.empSize = data["empSize"];
            this.excludeAreaCode = data["excludeAreaCode"];
            this.excludeCountiesList = data["excludeCountiesList"];
            this.excludeCountyIds = data["excludeCountyIds"];
            this.excludeMSA = data["excludeMSA"];
            this.excludeState = data["excludeState"];
            this.excludeZip = data["excludeZip"];
            this.includeCountyIds = data["includeCountyIds"];
            this.linesSearch = data["linesSearch"];
            this.linesSearchCriteria = data["linesSearchCriteria"];
            this.msa = data["msa"];
            this.msaConcatenated = data["msaConcatenated"];
            this.pEmpCriteria = data["pEmpCriteria"];
            this.pVolume = data["pVolume"];
            this.revenueCriteria = data["revenueCriteria"];
            this.revenueValue = data["revenueValue"];
            this.sicCodes = data["sicCodes"];
            this.sicids = data["sicids"];
            this.state = data["state"];
            this.titleSearch = data["titleSearch"];
            this.titleSearchCriteria = data["titleSearchCriteria"];
            this.typeCriteria = data["typeCriteria"];
            this.typeField = data["typeField"];
            this.zip = data["zip"];
            this.isRetail = data["isRetail"];
            this.isWholesale = data["isWholesale"];
            this.minorityOwned = data["minorityOwned"];
            this.carrierManageCrieteria = data["carrierManageCrieteria"];
        }
    }

    static fromJS(data: any): ADSearchInput {
        data = typeof data === 'object' ? data : {};
        let result = new ADSearchInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryCriteria"] = this.queryCriteria;
        data["queryName"] = this.queryName;
        data["affiliations"] = this.affiliations;
        data["agencyManagement"] = this.agencyManagement;
        data["agencyMgntCriteria"] = this.agencyMgntCriteria;
        data["areaCode"] = this.areaCode;
        data["commPercent"] = this.commPercent;
        data["companyLines"] = this.companyLines;
        data["companyName"] = this.companyName;
        data["companyNameType"] = this.companyNameType;
        data["country"] = this.country;
        data["county"] = this.county;
        data["countyConcatenated"] = this.countyConcatenated;
        data["countyIDs"] = this.countyIDs;
        data["empSize"] = this.empSize;
        data["excludeAreaCode"] = this.excludeAreaCode;
        data["excludeCountiesList"] = this.excludeCountiesList;
        data["excludeCountyIds"] = this.excludeCountyIds;
        data["excludeMSA"] = this.excludeMSA;
        data["excludeState"] = this.excludeState;
        data["excludeZip"] = this.excludeZip;
        data["includeCountyIds"] = this.includeCountyIds;
        data["linesSearch"] = this.linesSearch;
        data["linesSearchCriteria"] = this.linesSearchCriteria;
        data["msa"] = this.msa;
        data["msaConcatenated"] = this.msaConcatenated;
        data["pEmpCriteria"] = this.pEmpCriteria;
        data["pVolume"] = this.pVolume;
        data["revenueCriteria"] = this.revenueCriteria;
        data["revenueValue"] = this.revenueValue;
        data["sicCodes"] = this.sicCodes;
        data["sicids"] = this.sicids;
        data["state"] = this.state;
        data["titleSearch"] = this.titleSearch;
        data["titleSearchCriteria"] = this.titleSearchCriteria;
        data["typeCriteria"] = this.typeCriteria;
        data["typeField"] = this.typeField;
        data["zip"] = this.zip;
        data["isRetail"] = this.isRetail;
        data["isWholesale"] = this.isWholesale;
        data["minorityOwned"] = this.minorityOwned;
        data["carrierManageCrieteria"] = this.carrierManageCrieteria;
        return data; 
    }

    clone(): ADSearchInput {
        const json = this.toJSON();
        let result = new ADSearchInput();
        result.init(json);
        return result;
    }
}

export interface IADSearchInput {
    queryCriteria: string | undefined;
    queryName: string | undefined;
    affiliations: string | undefined;
    agencyManagement: string | undefined;
    agencyMgntCriteria: string | undefined;
    areaCode: string | undefined;
    commPercent: string | undefined;
    companyLines: string | undefined;
    companyName: string | undefined;
    companyNameType: string | undefined;
    country: string | undefined;
    county: string | undefined;
    countyConcatenated: string | undefined;
    countyIDs: string | undefined;
    empSize: string | undefined;
    excludeAreaCode: string | undefined;
    excludeCountiesList: string | undefined;
    excludeCountyIds: string | undefined;
    excludeMSA: string | undefined;
    excludeState: string | undefined;
    excludeZip: string | undefined;
    includeCountyIds: string | undefined;
    linesSearch: string | undefined;
    linesSearchCriteria: string | undefined;
    msa: string | undefined;
    msaConcatenated: string | undefined;
    pEmpCriteria: string | undefined;
    pVolume: string | undefined;
    revenueCriteria: string | undefined;
    revenueValue: string | undefined;
    sicCodes: string | undefined;
    sicids: string | undefined;
    state: string | undefined;
    titleSearch: string | undefined;
    titleSearchCriteria: string | undefined;
    typeCriteria: string | undefined;
    typeField: string | undefined;
    zip: string | undefined;
    isRetail: boolean | undefined;
    isWholesale: boolean | undefined;
    minorityOwned: string | undefined;
    carrierManageCrieteria: string | undefined;
}

export class ADCountsDto implements IADCountsDto {
    adCounts: ADCounts | undefined;
    adQueries: ADQueries | undefined;

    constructor(data?: IADCountsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adCounts = data["adCounts"] ? ADCounts.fromJS(data["adCounts"]) : <any>undefined;
            this.adQueries = data["adQueries"] ? ADQueries.fromJS(data["adQueries"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ADCountsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ADCountsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adCounts"] = this.adCounts ? this.adCounts.toJSON() : <any>undefined;
        data["adQueries"] = this.adQueries ? this.adQueries.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ADCountsDto {
        const json = this.toJSON();
        let result = new ADCountsDto();
        result.init(json);
        return result;
    }
}

export interface IADCountsDto {
    adCounts: ADCounts | undefined;
    adQueries: ADQueries | undefined;
}

export class ADCounts implements IADCounts {
    agencyListCount: string | undefined;
    adContactsCount: string | undefined;
    adEmailCount: string | undefined;

    constructor(data?: IADCounts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.agencyListCount = data["agencyListCount"];
            this.adContactsCount = data["adContactsCount"];
            this.adEmailCount = data["adEmailCount"];
        }
    }

    static fromJS(data: any): ADCounts {
        data = typeof data === 'object' ? data : {};
        let result = new ADCounts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agencyListCount"] = this.agencyListCount;
        data["adContactsCount"] = this.adContactsCount;
        data["adEmailCount"] = this.adEmailCount;
        return data; 
    }

    clone(): ADCounts {
        const json = this.toJSON();
        let result = new ADCounts();
        result.init(json);
        return result;
    }
}

export interface IADCounts {
    agencyListCount: string | undefined;
    adContactsCount: string | undefined;
    adEmailCount: string | undefined;
}

export class ADQueries implements IADQueries {
    agencyQuery: string | undefined;
    sqlQuery: string | undefined;
    adCountQuery: string | undefined;
    adContactsCountQuery: string | undefined;
    adEmailCountQuery: string | undefined;

    constructor(data?: IADQueries) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.agencyQuery = data["agencyQuery"];
            this.sqlQuery = data["sqlQuery"];
            this.adCountQuery = data["adCountQuery"];
            this.adContactsCountQuery = data["adContactsCountQuery"];
            this.adEmailCountQuery = data["adEmailCountQuery"];
        }
    }

    static fromJS(data: any): ADQueries {
        data = typeof data === 'object' ? data : {};
        let result = new ADQueries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agencyQuery"] = this.agencyQuery;
        data["sqlQuery"] = this.sqlQuery;
        data["adCountQuery"] = this.adCountQuery;
        data["adContactsCountQuery"] = this.adContactsCountQuery;
        data["adEmailCountQuery"] = this.adEmailCountQuery;
        return data; 
    }

    clone(): ADQueries {
        const json = this.toJSON();
        let result = new ADQueries();
        result.init(json);
        return result;
    }
}

export interface IADQueries {
    agencyQuery: string | undefined;
    sqlQuery: string | undefined;
    adCountQuery: string | undefined;
    adContactsCountQuery: string | undefined;
    adEmailCountQuery: string | undefined;
}

export class AdBuyNames implements IAdBuyNames {
    recordPrice: RecordPriceDto | undefined;
    adNames: ADName[] | undefined;

    constructor(data?: IAdBuyNames) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recordPrice = data["recordPrice"] ? RecordPriceDto.fromJS(data["recordPrice"]) : <any>undefined;
            if (data["adNames"] && data["adNames"].constructor === Array) {
                this.adNames = [];
                for (let item of data["adNames"])
                    this.adNames.push(ADName.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdBuyNames {
        data = typeof data === 'object' ? data : {};
        let result = new AdBuyNames();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordPrice"] = this.recordPrice ? this.recordPrice.toJSON() : <any>undefined;
        if (this.adNames && this.adNames.constructor === Array) {
            data["adNames"] = [];
            for (let item of this.adNames)
                data["adNames"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AdBuyNames {
        const json = this.toJSON();
        let result = new AdBuyNames();
        result.init(json);
        return result;
    }
}

export interface IAdBuyNames {
    recordPrice: RecordPriceDto | undefined;
    adNames: ADName[] | undefined;
}

export class RecordPriceDto implements IRecordPriceDto {
    agencyRecPrice: number | undefined;
    contactRecPrice: number | undefined;

    constructor(data?: IRecordPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.agencyRecPrice = data["agencyRecPrice"];
            this.contactRecPrice = data["contactRecPrice"];
        }
    }

    static fromJS(data: any): RecordPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecordPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agencyRecPrice"] = this.agencyRecPrice;
        data["contactRecPrice"] = this.contactRecPrice;
        return data; 
    }

    clone(): RecordPriceDto {
        const json = this.toJSON();
        let result = new RecordPriceDto();
        result.init(json);
        return result;
    }
}

export interface IRecordPriceDto {
    agencyRecPrice: number | undefined;
    contactRecPrice: number | undefined;
}

export class ADName implements IADName {
    accountName: string | undefined;
    state: string | undefined;

    constructor(data?: IADName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountName = data["accountName"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): ADName {
        data = typeof data === 'object' ? data : {};
        let result = new ADName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["state"] = this.state;
        return data; 
    }

    clone(): ADName {
        const json = this.toJSON();
        let result = new ADName();
        result.init(json);
        return result;
    }
}

export interface IADName {
    accountName: string | undefined;
    state: string | undefined;
}

export class ADPurchaseUpdate implements IADPurchaseUpdate {
    query: string | undefined;
    queryId: number | undefined;

    constructor(data?: IADPurchaseUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.query = data["query"];
            this.queryId = data["queryId"];
        }
    }

    static fromJS(data: any): ADPurchaseUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new ADPurchaseUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["query"] = this.query;
        data["queryId"] = this.queryId;
        return data; 
    }

    clone(): ADPurchaseUpdate {
        const json = this.toJSON();
        let result = new ADPurchaseUpdate();
        result.init(json);
        return result;
    }
}

export interface IADPurchaseUpdate {
    query: string | undefined;
    queryId: number | undefined;
}

export class ADNamesDto implements IADNamesDto {
    adNames: ADName[] | undefined;
    queryId: number | undefined;

    constructor(data?: IADNamesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["adNames"] && data["adNames"].constructor === Array) {
                this.adNames = [];
                for (let item of data["adNames"])
                    this.adNames.push(ADName.fromJS(item));
            }
            this.queryId = data["queryId"];
        }
    }

    static fromJS(data: any): ADNamesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ADNamesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.adNames && this.adNames.constructor === Array) {
            data["adNames"] = [];
            for (let item of this.adNames)
                data["adNames"].push(item.toJSON());
        }
        data["queryId"] = this.queryId;
        return data; 
    }

    clone(): ADNamesDto {
        const json = this.toJSON();
        let result = new ADNamesDto();
        result.init(json);
        return result;
    }
}

export interface IADNamesDto {
    adNames: ADName[] | undefined;
    queryId: number | undefined;
}

export class AnalyzeInput implements IAnalyzeInput {
    agencyQuery: string | undefined;
    firstValue: string | undefined;
    secondValue: string | undefined;
    sicCodes: string | undefined;

    constructor(data?: IAnalyzeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.agencyQuery = data["agencyQuery"];
            this.firstValue = data["firstValue"];
            this.secondValue = data["secondValue"];
            this.sicCodes = data["sicCodes"];
        }
    }

    static fromJS(data: any): AnalyzeInput {
        data = typeof data === 'object' ? data : {};
        let result = new AnalyzeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agencyQuery"] = this.agencyQuery;
        data["firstValue"] = this.firstValue;
        data["secondValue"] = this.secondValue;
        data["sicCodes"] = this.sicCodes;
        return data; 
    }

    clone(): AnalyzeInput {
        const json = this.toJSON();
        let result = new AnalyzeInput();
        result.init(json);
        return result;
    }
}

export interface IAnalyzeInput {
    agencyQuery: string | undefined;
    firstValue: string | undefined;
    secondValue: string | undefined;
    sicCodes: string | undefined;
}

export class BreakdownDto implements IBreakdownDto {
    firstValue: string | undefined;
    secondValue: string | undefined;
    records: string | undefined;
    description: string | undefined;

    constructor(data?: IBreakdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstValue = data["firstValue"];
            this.secondValue = data["secondValue"];
            this.records = data["records"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): BreakdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new BreakdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstValue"] = this.firstValue;
        data["secondValue"] = this.secondValue;
        data["records"] = this.records;
        data["description"] = this.description;
        return data; 
    }

    clone(): BreakdownDto {
        const json = this.toJSON();
        let result = new BreakdownDto();
        result.init(json);
        return result;
    }
}

export interface IBreakdownDto {
    firstValue: string | undefined;
    secondValue: string | undefined;
    records: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfSpecialAffiliationDto implements IPagedResultDtoOfSpecialAffiliationDto {
    totalCount: number | undefined;
    items: SpecialAffiliationDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSpecialAffiliationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SpecialAffiliationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSpecialAffiliationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSpecialAffiliationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfSpecialAffiliationDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSpecialAffiliationDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSpecialAffiliationDto {
    totalCount: number | undefined;
    items: SpecialAffiliationDto[] | undefined;
}

export class SpecialAffiliationDto implements ISpecialAffiliationDto {
    name: string | undefined;
    isActive: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ISpecialAffiliationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SpecialAffiliationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialAffiliationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SpecialAffiliationDto {
        const json = this.toJSON();
        let result = new SpecialAffiliationDto();
        result.init(json);
        return result;
    }
}

export interface ISpecialAffiliationDto {
    name: string | undefined;
    isActive: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAMGListDto implements IPagedResultDtoOfAMGListDto {
    totalCount: number | undefined;
    items: AMGListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAMGListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AMGListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAMGListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAMGListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAMGListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAMGListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAMGListDto {
    totalCount: number | undefined;
    items: AMGListDto[] | undefined;
}

export class AMGListDto implements IAMGListDto {
    aList: string | undefined;
    isActive: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IAMGListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.aList = data["aList"];
            this.isActive = data["isActive"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AMGListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AMGListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aList"] = this.aList;
        data["isActive"] = this.isActive;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AMGListDto {
        const json = this.toJSON();
        let result = new AMGListDto();
        result.init(json);
        return result;
    }
}

export interface IAMGListDto {
    aList: string | undefined;
    isActive: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBdOrderDto implements IPagedResultDtoOfBdOrderDto {
    totalCount: number | undefined;
    items: BdOrderDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBdOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BdOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBdOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBdOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfBdOrderDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfBdOrderDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfBdOrderDto {
    totalCount: number | undefined;
    items: BdOrderDto[] | undefined;
}

export class BdOrderDto implements IBdOrderDto {
    searchID: number | undefined;
    salesUser: string | undefined;
    description: string | undefined;
    recordCount: number | undefined;
    creditsUsed: number | undefined;
    recordPrice: number | undefined;
    orderValue: number | undefined;
    paymentType: string | undefined;
    ccTransactionId: string | undefined;
    ccAuthorization: string | undefined;
    checkNumber: string | undefined;
    active: boolean | undefined;
    orderNotes: string | undefined;
    ccNum: string | undefined;
    xDatesPurchased: boolean | undefined;
    xDateOrdValue: number | undefined;
    xDatesPurchasedCnt: number | undefined;
    xDatesOrderAmt: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IBdOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchID = data["searchID"];
            this.salesUser = data["salesUser"];
            this.description = data["description"];
            this.recordCount = data["recordCount"];
            this.creditsUsed = data["creditsUsed"];
            this.recordPrice = data["recordPrice"];
            this.orderValue = data["orderValue"];
            this.paymentType = data["paymentType"];
            this.ccTransactionId = data["ccTransactionId"];
            this.ccAuthorization = data["ccAuthorization"];
            this.checkNumber = data["checkNumber"];
            this.active = data["active"];
            this.orderNotes = data["orderNotes"];
            this.ccNum = data["ccNum"];
            this.xDatesPurchased = data["xDatesPurchased"];
            this.xDateOrdValue = data["xDateOrdValue"];
            this.xDatesPurchasedCnt = data["xDatesPurchasedCnt"];
            this.xDatesOrderAmt = data["xDatesOrderAmt"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BdOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new BdOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchID"] = this.searchID;
        data["salesUser"] = this.salesUser;
        data["description"] = this.description;
        data["recordCount"] = this.recordCount;
        data["creditsUsed"] = this.creditsUsed;
        data["recordPrice"] = this.recordPrice;
        data["orderValue"] = this.orderValue;
        data["paymentType"] = this.paymentType;
        data["ccTransactionId"] = this.ccTransactionId;
        data["ccAuthorization"] = this.ccAuthorization;
        data["checkNumber"] = this.checkNumber;
        data["active"] = this.active;
        data["orderNotes"] = this.orderNotes;
        data["ccNum"] = this.ccNum;
        data["xDatesPurchased"] = this.xDatesPurchased;
        data["xDateOrdValue"] = this.xDateOrdValue;
        data["xDatesPurchasedCnt"] = this.xDatesPurchasedCnt;
        data["xDatesOrderAmt"] = this.xDatesOrderAmt;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BdOrderDto {
        const json = this.toJSON();
        let result = new BdOrderDto();
        result.init(json);
        return result;
    }
}

export interface IBdOrderDto {
    searchID: number | undefined;
    salesUser: string | undefined;
    description: string | undefined;
    recordCount: number | undefined;
    creditsUsed: number | undefined;
    recordPrice: number | undefined;
    orderValue: number | undefined;
    paymentType: string | undefined;
    ccTransactionId: string | undefined;
    ccAuthorization: string | undefined;
    checkNumber: string | undefined;
    active: boolean | undefined;
    orderNotes: string | undefined;
    ccNum: string | undefined;
    xDatesPurchased: boolean | undefined;
    xDateOrdValue: number | undefined;
    xDatesPurchasedCnt: number | undefined;
    xDatesOrderAmt: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class BdReceiptDto implements IBdReceiptDto {
    neilson: CustomerDto | undefined;
    customer: CustomerDto | undefined;
    order: BdOrderDto | undefined;

    constructor(data?: IBdReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.neilson = data["neilson"] ? CustomerDto.fromJS(data["neilson"]) : <any>undefined;
            this.customer = data["customer"] ? CustomerDto.fromJS(data["customer"]) : <any>undefined;
            this.order = data["order"] ? BdOrderDto.fromJS(data["order"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BdReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new BdReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["neilson"] = this.neilson ? this.neilson.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        return data; 
    }

    clone(): BdReceiptDto {
        const json = this.toJSON();
        let result = new BdReceiptDto();
        result.init(json);
        return result;
    }
}

export interface IBdReceiptDto {
    neilson: CustomerDto | undefined;
    customer: CustomerDto | undefined;
    order: BdOrderDto | undefined;
}

export class BdOrderInput implements IBdOrderInput {
    searchID: number | undefined;
    salesUser: string | undefined;
    description: string | undefined;
    recordCount: number | undefined;
    creditsUsed: number | undefined;
    recordPrice: number | undefined;
    orderValue: number | undefined;
    paymentType: string | undefined;
    ccTransactionId: string | undefined;
    ccAuthorization: string | undefined;
    checkNumber: string | undefined;
    active: boolean | undefined;
    orderNotes: string | undefined;
    ccNum: string | undefined;
    xDatesPurchased: boolean | undefined;
    xDateOrdValue: number | undefined;
    xDatesPurchasedCnt: number | undefined;
    xDatesOrderAmt: number | undefined;

    constructor(data?: IBdOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchID = data["searchID"];
            this.salesUser = data["salesUser"];
            this.description = data["description"];
            this.recordCount = data["recordCount"];
            this.creditsUsed = data["creditsUsed"];
            this.recordPrice = data["recordPrice"];
            this.orderValue = data["orderValue"];
            this.paymentType = data["paymentType"];
            this.ccTransactionId = data["ccTransactionId"];
            this.ccAuthorization = data["ccAuthorization"];
            this.checkNumber = data["checkNumber"];
            this.active = data["active"];
            this.orderNotes = data["orderNotes"];
            this.ccNum = data["ccNum"];
            this.xDatesPurchased = data["xDatesPurchased"];
            this.xDateOrdValue = data["xDateOrdValue"];
            this.xDatesPurchasedCnt = data["xDatesPurchasedCnt"];
            this.xDatesOrderAmt = data["xDatesOrderAmt"];
        }
    }

    static fromJS(data: any): BdOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new BdOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchID"] = this.searchID;
        data["salesUser"] = this.salesUser;
        data["description"] = this.description;
        data["recordCount"] = this.recordCount;
        data["creditsUsed"] = this.creditsUsed;
        data["recordPrice"] = this.recordPrice;
        data["orderValue"] = this.orderValue;
        data["paymentType"] = this.paymentType;
        data["ccTransactionId"] = this.ccTransactionId;
        data["ccAuthorization"] = this.ccAuthorization;
        data["checkNumber"] = this.checkNumber;
        data["active"] = this.active;
        data["orderNotes"] = this.orderNotes;
        data["ccNum"] = this.ccNum;
        data["xDatesPurchased"] = this.xDatesPurchased;
        data["xDateOrdValue"] = this.xDateOrdValue;
        data["xDatesPurchasedCnt"] = this.xDatesPurchasedCnt;
        data["xDatesOrderAmt"] = this.xDatesOrderAmt;
        return data; 
    }

    clone(): BdOrderInput {
        const json = this.toJSON();
        let result = new BdOrderInput();
        result.init(json);
        return result;
    }
}

export interface IBdOrderInput {
    searchID: number | undefined;
    salesUser: string | undefined;
    description: string | undefined;
    recordCount: number | undefined;
    creditsUsed: number | undefined;
    recordPrice: number | undefined;
    orderValue: number | undefined;
    paymentType: string | undefined;
    ccTransactionId: string | undefined;
    ccAuthorization: string | undefined;
    checkNumber: string | undefined;
    active: boolean | undefined;
    orderNotes: string | undefined;
    ccNum: string | undefined;
    xDatesPurchased: boolean | undefined;
    xDateOrdValue: number | undefined;
    xDatesPurchasedCnt: number | undefined;
    xDatesOrderAmt: number | undefined;
}

export class PurchaseInput implements IPurchaseInput {
    orderId: number | undefined;
    purchaseType: PurchaseInputPurchaseType | undefined;
    recordQuery: string | undefined;
    recordCount: number | undefined;
    xDateQuery: string | undefined;
    xDateCount: number | undefined;
    xDateMonths: string | undefined;

    constructor(data?: IPurchaseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.purchaseType = data["purchaseType"];
            this.recordQuery = data["recordQuery"];
            this.recordCount = data["recordCount"];
            this.xDateQuery = data["xDateQuery"];
            this.xDateCount = data["xDateCount"];
            this.xDateMonths = data["xDateMonths"];
        }
    }

    static fromJS(data: any): PurchaseInput {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["purchaseType"] = this.purchaseType;
        data["recordQuery"] = this.recordQuery;
        data["recordCount"] = this.recordCount;
        data["xDateQuery"] = this.xDateQuery;
        data["xDateCount"] = this.xDateCount;
        data["xDateMonths"] = this.xDateMonths;
        return data; 
    }

    clone(): PurchaseInput {
        const json = this.toJSON();
        let result = new PurchaseInput();
        result.init(json);
        return result;
    }
}

export interface IPurchaseInput {
    orderId: number | undefined;
    purchaseType: PurchaseInputPurchaseType | undefined;
    recordQuery: string | undefined;
    recordCount: number | undefined;
    xDateQuery: string | undefined;
    xDateCount: number | undefined;
    xDateMonths: string | undefined;
}

export class PagedResultDtoOfBDSearchDto implements IPagedResultDtoOfBDSearchDto {
    totalCount: number | undefined;
    items: BDSearchDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBDSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BDSearchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBDSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBDSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfBDSearchDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfBDSearchDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfBDSearchDto {
    totalCount: number | undefined;
    items: BDSearchDto[] | undefined;
}

export class BDSearchDto implements IBDSearchDto {
    searchName: string | undefined;
    originalCount: number | undefined;
    companyName: string | undefined;
    companyBeginsContains: string | undefined;
    employeesFrom: number | undefined;
    employeesTo: number | undefined;
    companyAndOr: string | undefined;
    salesFrom: number | undefined;
    salesTo: number | undefined;
    locations: string | undefined;
    manufacturing: string | undefined;
    state: string | undefined;
    county: string | undefined;
    zip: string | undefined;
    msa: string | undefined;
    areaCode: string | undefined;
    sic: string | undefined;
    siciDs: string | undefined;
    xDatesMonth: string | undefined;
    exclude_State: string | undefined;
    exclude_County: string | undefined;
    exclude_Zip: string | undefined;
    exclude_MSA: string | undefined;
    exclude_AreaCode: string | undefined;
    sqlQuery: string | undefined;
    queryfilename: string | undefined;
    userId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IBDSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchName = data["searchName"];
            this.originalCount = data["originalCount"];
            this.companyName = data["companyName"];
            this.companyBeginsContains = data["companyBeginsContains"];
            this.employeesFrom = data["employeesFrom"];
            this.employeesTo = data["employeesTo"];
            this.companyAndOr = data["companyAndOr"];
            this.salesFrom = data["salesFrom"];
            this.salesTo = data["salesTo"];
            this.locations = data["locations"];
            this.manufacturing = data["manufacturing"];
            this.state = data["state"];
            this.county = data["county"];
            this.zip = data["zip"];
            this.msa = data["msa"];
            this.areaCode = data["areaCode"];
            this.sic = data["sic"];
            this.siciDs = data["siciDs"];
            this.xDatesMonth = data["xDatesMonth"];
            this.exclude_State = data["exclude_State"];
            this.exclude_County = data["exclude_County"];
            this.exclude_Zip = data["exclude_Zip"];
            this.exclude_MSA = data["exclude_MSA"];
            this.exclude_AreaCode = data["exclude_AreaCode"];
            this.sqlQuery = data["sqlQuery"];
            this.queryfilename = data["queryfilename"];
            this.userId = data["userId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BDSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new BDSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchName"] = this.searchName;
        data["originalCount"] = this.originalCount;
        data["companyName"] = this.companyName;
        data["companyBeginsContains"] = this.companyBeginsContains;
        data["employeesFrom"] = this.employeesFrom;
        data["employeesTo"] = this.employeesTo;
        data["companyAndOr"] = this.companyAndOr;
        data["salesFrom"] = this.salesFrom;
        data["salesTo"] = this.salesTo;
        data["locations"] = this.locations;
        data["manufacturing"] = this.manufacturing;
        data["state"] = this.state;
        data["county"] = this.county;
        data["zip"] = this.zip;
        data["msa"] = this.msa;
        data["areaCode"] = this.areaCode;
        data["sic"] = this.sic;
        data["siciDs"] = this.siciDs;
        data["xDatesMonth"] = this.xDatesMonth;
        data["exclude_State"] = this.exclude_State;
        data["exclude_County"] = this.exclude_County;
        data["exclude_Zip"] = this.exclude_Zip;
        data["exclude_MSA"] = this.exclude_MSA;
        data["exclude_AreaCode"] = this.exclude_AreaCode;
        data["sqlQuery"] = this.sqlQuery;
        data["queryfilename"] = this.queryfilename;
        data["userId"] = this.userId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BDSearchDto {
        const json = this.toJSON();
        let result = new BDSearchDto();
        result.init(json);
        return result;
    }
}

export interface IBDSearchDto {
    searchName: string | undefined;
    originalCount: number | undefined;
    companyName: string | undefined;
    companyBeginsContains: string | undefined;
    employeesFrom: number | undefined;
    employeesTo: number | undefined;
    companyAndOr: string | undefined;
    salesFrom: number | undefined;
    salesTo: number | undefined;
    locations: string | undefined;
    manufacturing: string | undefined;
    state: string | undefined;
    county: string | undefined;
    zip: string | undefined;
    msa: string | undefined;
    areaCode: string | undefined;
    sic: string | undefined;
    siciDs: string | undefined;
    xDatesMonth: string | undefined;
    exclude_State: string | undefined;
    exclude_County: string | undefined;
    exclude_Zip: string | undefined;
    exclude_MSA: string | undefined;
    exclude_AreaCode: string | undefined;
    sqlQuery: string | undefined;
    queryfilename: string | undefined;
    userId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class BDSearchInput implements IBDSearchInput {
    searchName: string | undefined;
    isNewQuery: boolean | undefined;
    originalCount: number | undefined;
    companyName: string | undefined;
    companyBeginsContains: string | undefined;
    employeesFrom: number | undefined;
    employeesTo: number | undefined;
    companyAndOr: string | undefined;
    salesFrom: number | undefined;
    salesTo: number | undefined;
    locations: string | undefined;
    manufacturing: string | undefined;
    state: string | undefined;
    includeCountyIds: string | undefined;
    county: string | undefined;
    zip: string | undefined;
    msa: string | undefined;
    areaCode: string | undefined;
    sic: string | undefined;
    siciDs: string | undefined;
    xDatesMonth: string | undefined;
    iL_SlectedStates: string | undefined;
    iL_EXSlectedStates: string | undefined;
    getAllStates: string | undefined;
    exclude_State: string | undefined;
    exclude_County: string | undefined;
    exclude_Zip: string | undefined;
    exclude_MSA: string | undefined;
    exclude_AreaCode: string | undefined;
    sqlQuery: string | undefined;
    queryfilename: string | undefined;
    userId: number | undefined;

    constructor(data?: IBDSearchInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchName = data["searchName"];
            this.isNewQuery = data["isNewQuery"];
            this.originalCount = data["originalCount"];
            this.companyName = data["companyName"];
            this.companyBeginsContains = data["companyBeginsContains"];
            this.employeesFrom = data["employeesFrom"];
            this.employeesTo = data["employeesTo"];
            this.companyAndOr = data["companyAndOr"];
            this.salesFrom = data["salesFrom"];
            this.salesTo = data["salesTo"];
            this.locations = data["locations"];
            this.manufacturing = data["manufacturing"];
            this.state = data["state"];
            this.includeCountyIds = data["includeCountyIds"];
            this.county = data["county"];
            this.zip = data["zip"];
            this.msa = data["msa"];
            this.areaCode = data["areaCode"];
            this.sic = data["sic"];
            this.siciDs = data["siciDs"];
            this.xDatesMonth = data["xDatesMonth"];
            this.iL_SlectedStates = data["iL_SlectedStates"];
            this.iL_EXSlectedStates = data["iL_EXSlectedStates"];
            this.getAllStates = data["getAllStates"];
            this.exclude_State = data["exclude_State"];
            this.exclude_County = data["exclude_County"];
            this.exclude_Zip = data["exclude_Zip"];
            this.exclude_MSA = data["exclude_MSA"];
            this.exclude_AreaCode = data["exclude_AreaCode"];
            this.sqlQuery = data["sqlQuery"];
            this.queryfilename = data["queryfilename"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): BDSearchInput {
        data = typeof data === 'object' ? data : {};
        let result = new BDSearchInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchName"] = this.searchName;
        data["isNewQuery"] = this.isNewQuery;
        data["originalCount"] = this.originalCount;
        data["companyName"] = this.companyName;
        data["companyBeginsContains"] = this.companyBeginsContains;
        data["employeesFrom"] = this.employeesFrom;
        data["employeesTo"] = this.employeesTo;
        data["companyAndOr"] = this.companyAndOr;
        data["salesFrom"] = this.salesFrom;
        data["salesTo"] = this.salesTo;
        data["locations"] = this.locations;
        data["manufacturing"] = this.manufacturing;
        data["state"] = this.state;
        data["includeCountyIds"] = this.includeCountyIds;
        data["county"] = this.county;
        data["zip"] = this.zip;
        data["msa"] = this.msa;
        data["areaCode"] = this.areaCode;
        data["sic"] = this.sic;
        data["siciDs"] = this.siciDs;
        data["xDatesMonth"] = this.xDatesMonth;
        data["iL_SlectedStates"] = this.iL_SlectedStates;
        data["iL_EXSlectedStates"] = this.iL_EXSlectedStates;
        data["getAllStates"] = this.getAllStates;
        data["exclude_State"] = this.exclude_State;
        data["exclude_County"] = this.exclude_County;
        data["exclude_Zip"] = this.exclude_Zip;
        data["exclude_MSA"] = this.exclude_MSA;
        data["exclude_AreaCode"] = this.exclude_AreaCode;
        data["sqlQuery"] = this.sqlQuery;
        data["queryfilename"] = this.queryfilename;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): BDSearchInput {
        const json = this.toJSON();
        let result = new BDSearchInput();
        result.init(json);
        return result;
    }
}

export interface IBDSearchInput {
    searchName: string | undefined;
    isNewQuery: boolean | undefined;
    originalCount: number | undefined;
    companyName: string | undefined;
    companyBeginsContains: string | undefined;
    employeesFrom: number | undefined;
    employeesTo: number | undefined;
    companyAndOr: string | undefined;
    salesFrom: number | undefined;
    salesTo: number | undefined;
    locations: string | undefined;
    manufacturing: string | undefined;
    state: string | undefined;
    includeCountyIds: string | undefined;
    county: string | undefined;
    zip: string | undefined;
    msa: string | undefined;
    areaCode: string | undefined;
    sic: string | undefined;
    siciDs: string | undefined;
    xDatesMonth: string | undefined;
    iL_SlectedStates: string | undefined;
    iL_EXSlectedStates: string | undefined;
    getAllStates: string | undefined;
    exclude_State: string | undefined;
    exclude_County: string | undefined;
    exclude_Zip: string | undefined;
    exclude_MSA: string | undefined;
    exclude_AreaCode: string | undefined;
    sqlQuery: string | undefined;
    queryfilename: string | undefined;
    userId: number | undefined;
}

export class AnalyzeBDInput implements IAnalyzeBDInput {
    businessQuery: string | undefined;
    firstValue: string | undefined;
    secondValue: string | undefined;
    thirdValue: string | undefined;

    constructor(data?: IAnalyzeBDInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.businessQuery = data["businessQuery"];
            this.firstValue = data["firstValue"];
            this.secondValue = data["secondValue"];
            this.thirdValue = data["thirdValue"];
        }
    }

    static fromJS(data: any): AnalyzeBDInput {
        data = typeof data === 'object' ? data : {};
        let result = new AnalyzeBDInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessQuery"] = this.businessQuery;
        data["firstValue"] = this.firstValue;
        data["secondValue"] = this.secondValue;
        data["thirdValue"] = this.thirdValue;
        return data; 
    }

    clone(): AnalyzeBDInput {
        const json = this.toJSON();
        let result = new AnalyzeBDInput();
        result.init(json);
        return result;
    }
}

export interface IAnalyzeBDInput {
    businessQuery: string | undefined;
    firstValue: string | undefined;
    secondValue: string | undefined;
    thirdValue: string | undefined;
}

export class BreakdownBDDto implements IBreakdownBDDto {
    firstValue: string | undefined;
    secondValue: string | undefined;
    thirdValue: string | undefined;
    records: string | undefined;
    description: string | undefined;

    constructor(data?: IBreakdownBDDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstValue = data["firstValue"];
            this.secondValue = data["secondValue"];
            this.thirdValue = data["thirdValue"];
            this.records = data["records"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): BreakdownBDDto {
        data = typeof data === 'object' ? data : {};
        let result = new BreakdownBDDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstValue"] = this.firstValue;
        data["secondValue"] = this.secondValue;
        data["thirdValue"] = this.thirdValue;
        data["records"] = this.records;
        data["description"] = this.description;
        return data; 
    }

    clone(): BreakdownBDDto {
        const json = this.toJSON();
        let result = new BreakdownBDDto();
        result.init(json);
        return result;
    }
}

export interface IBreakdownBDDto {
    firstValue: string | undefined;
    secondValue: string | undefined;
    thirdValue: string | undefined;
    records: string | undefined;
    description: string | undefined;
}

export class BDCountsDto implements IBDCountsDto {
    bdCounts: BDCounts | undefined;
    bdQueries: BDQueries | undefined;

    constructor(data?: IBDCountsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bdCounts = data["bdCounts"] ? BDCounts.fromJS(data["bdCounts"]) : <any>undefined;
            this.bdQueries = data["bdQueries"] ? BDQueries.fromJS(data["bdQueries"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BDCountsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BDCountsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bdCounts"] = this.bdCounts ? this.bdCounts.toJSON() : <any>undefined;
        data["bdQueries"] = this.bdQueries ? this.bdQueries.toJSON() : <any>undefined;
        return data; 
    }

    clone(): BDCountsDto {
        const json = this.toJSON();
        let result = new BDCountsDto();
        result.init(json);
        return result;
    }
}

export interface IBDCountsDto {
    bdCounts: BDCounts | undefined;
    bdQueries: BDQueries | undefined;
}

export class BDCounts implements IBDCounts {
    businessListCount: number | undefined;
    bdxDateListCount: number | undefined;
    bdxDateBreakDown: XDateBreakdownDto[] | undefined;

    constructor(data?: IBDCounts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.businessListCount = data["businessListCount"];
            this.bdxDateListCount = data["bdxDateListCount"];
            if (data["bdxDateBreakDown"] && data["bdxDateBreakDown"].constructor === Array) {
                this.bdxDateBreakDown = [];
                for (let item of data["bdxDateBreakDown"])
                    this.bdxDateBreakDown.push(XDateBreakdownDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BDCounts {
        data = typeof data === 'object' ? data : {};
        let result = new BDCounts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessListCount"] = this.businessListCount;
        data["bdxDateListCount"] = this.bdxDateListCount;
        if (this.bdxDateBreakDown && this.bdxDateBreakDown.constructor === Array) {
            data["bdxDateBreakDown"] = [];
            for (let item of this.bdxDateBreakDown)
                data["bdxDateBreakDown"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BDCounts {
        const json = this.toJSON();
        let result = new BDCounts();
        result.init(json);
        return result;
    }
}

export interface IBDCounts {
    businessListCount: number | undefined;
    bdxDateListCount: number | undefined;
    bdxDateBreakDown: XDateBreakdownDto[] | undefined;
}

export class BDQueries implements IBDQueries {
    businessQuery: string | undefined;
    bdCountQuery: string | undefined;
    bdxDateQuery: string | undefined;
    bdxDateCountQuery: string | undefined;
    bdBreakdownQuery: string | undefined;
    xDatescondition: string | undefined;

    constructor(data?: IBDQueries) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.businessQuery = data["businessQuery"];
            this.bdCountQuery = data["bdCountQuery"];
            this.bdxDateQuery = data["bdxDateQuery"];
            this.bdxDateCountQuery = data["bdxDateCountQuery"];
            this.bdBreakdownQuery = data["bdBreakdownQuery"];
            this.xDatescondition = data["xDatescondition"];
        }
    }

    static fromJS(data: any): BDQueries {
        data = typeof data === 'object' ? data : {};
        let result = new BDQueries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessQuery"] = this.businessQuery;
        data["bdCountQuery"] = this.bdCountQuery;
        data["bdxDateQuery"] = this.bdxDateQuery;
        data["bdxDateCountQuery"] = this.bdxDateCountQuery;
        data["bdBreakdownQuery"] = this.bdBreakdownQuery;
        data["xDatescondition"] = this.xDatescondition;
        return data; 
    }

    clone(): BDQueries {
        const json = this.toJSON();
        let result = new BDQueries();
        result.init(json);
        return result;
    }
}

export interface IBDQueries {
    businessQuery: string | undefined;
    bdCountQuery: string | undefined;
    bdxDateQuery: string | undefined;
    bdxDateCountQuery: string | undefined;
    bdBreakdownQuery: string | undefined;
    xDatescondition: string | undefined;
}

export class XDateBreakdownDto implements IXDateBreakdownDto {
    workerscompmonth: string | undefined;
    xdatecount: string | undefined;

    constructor(data?: IXDateBreakdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workerscompmonth = data["workerscompmonth"];
            this.xdatecount = data["xdatecount"];
        }
    }

    static fromJS(data: any): XDateBreakdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new XDateBreakdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workerscompmonth"] = this.workerscompmonth;
        data["xdatecount"] = this.xdatecount;
        return data; 
    }

    clone(): XDateBreakdownDto {
        const json = this.toJSON();
        let result = new XDateBreakdownDto();
        result.init(json);
        return result;
    }
}

export interface IXDateBreakdownDto {
    workerscompmonth: string | undefined;
    xdatecount: string | undefined;
}

export class PagedResultDtoOfCarrierLineDto implements IPagedResultDtoOfCarrierLineDto {
    totalCount: number | undefined;
    items: CarrierLineDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCarrierLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CarrierLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCarrierLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCarrierLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCarrierLineDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCarrierLineDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCarrierLineDto {
    totalCount: number | undefined;
    items: CarrierLineDto[] | undefined;
}

export class CarrierLineDto implements ICarrierLineDto {
    name: string | undefined;
    isActive: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ICarrierLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CarrierLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarrierLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CarrierLineDto {
        const json = this.toJSON();
        let result = new CarrierLineDto();
        result.init(json);
        return result;
    }
}

export interface ICarrierLineDto {
    name: string | undefined;
    isActive: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CommonDto implements ICommonDto {
    name: string | undefined;
    isChecked: boolean | undefined;
    id: string | undefined;

    constructor(data?: ICommonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isChecked = data["isChecked"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommonDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isChecked"] = this.isChecked;
        data["id"] = this.id;
        return data; 
    }

    clone(): CommonDto {
        const json = this.toJSON();
        let result = new CommonDto();
        result.init(json);
        return result;
    }
}

export interface ICommonDto {
    name: string | undefined;
    isChecked: boolean | undefined;
    id: string | undefined;
}

export class ZipCodesDto implements IZipCodesDto {
    zip3Digits: CommonDto[] | undefined;
    zip5Digits: CommonDto[] | undefined;

    constructor(data?: IZipCodesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["zip3Digits"] && data["zip3Digits"].constructor === Array) {
                this.zip3Digits = [];
                for (let item of data["zip3Digits"])
                    this.zip3Digits.push(CommonDto.fromJS(item));
            }
            if (data["zip5Digits"] && data["zip5Digits"].constructor === Array) {
                this.zip5Digits = [];
                for (let item of data["zip5Digits"])
                    this.zip5Digits.push(CommonDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ZipCodesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZipCodesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.zip3Digits && this.zip3Digits.constructor === Array) {
            data["zip3Digits"] = [];
            for (let item of this.zip3Digits)
                data["zip3Digits"].push(item.toJSON());
        }
        if (this.zip5Digits && this.zip5Digits.constructor === Array) {
            data["zip5Digits"] = [];
            for (let item of this.zip5Digits)
                data["zip5Digits"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ZipCodesDto {
        const json = this.toJSON();
        let result = new ZipCodesDto();
        result.init(json);
        return result;
    }
}

export interface IZipCodesDto {
    zip3Digits: CommonDto[] | undefined;
    zip5Digits: CommonDto[] | undefined;
}

export class IndustryDto implements IIndustryDto {
    text: string | undefined;
    code: string | undefined;
    sic: string | undefined;
    level: number | undefined;
    expandable: boolean | undefined;
    sicid: string | undefined;
    isChecked: boolean | undefined;
    children: IndustryDto[] | undefined;

    constructor(data?: IIndustryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.text = data["text"];
            this.code = data["code"];
            this.sic = data["sic"];
            this.level = data["level"];
            this.expandable = data["expandable"];
            this.sicid = data["sicid"];
            this.isChecked = data["isChecked"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(IndustryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IndustryDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndustryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["code"] = this.code;
        data["sic"] = this.sic;
        data["level"] = this.level;
        data["expandable"] = this.expandable;
        data["sicid"] = this.sicid;
        data["isChecked"] = this.isChecked;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }

    clone(): IndustryDto {
        const json = this.toJSON();
        let result = new IndustryDto();
        result.init(json);
        return result;
    }
}

export interface IIndustryDto {
    text: string | undefined;
    code: string | undefined;
    sic: string | undefined;
    level: number | undefined;
    expandable: boolean | undefined;
    sicid: string | undefined;
    isChecked: boolean | undefined;
    children: IndustryDto[] | undefined;
}

export class PagedResultDtoOfCompanyTypeDto implements IPagedResultDtoOfCompanyTypeDto {
    totalCount: number | undefined;
    items: CompanyTypeDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCompanyTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CompanyTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCompanyTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCompanyTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCompanyTypeDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCompanyTypeDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCompanyTypeDto {
    totalCount: number | undefined;
    items: CompanyTypeDto[] | undefined;
}

export class CompanyTypeDto implements ICompanyTypeDto {
    name: string | undefined;
    isActive: boolean | undefined;
    isRetail: boolean | undefined;
    isWholesale: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ICompanyTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.isRetail = data["isRetail"];
            this.isWholesale = data["isWholesale"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CompanyTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["isRetail"] = this.isRetail;
        data["isWholesale"] = this.isWholesale;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CompanyTypeDto {
        const json = this.toJSON();
        let result = new CompanyTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyTypeDto {
    name: string | undefined;
    isActive: boolean | undefined;
    isRetail: boolean | undefined;
    isWholesale: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class PagedResultDtoOfContactTitleDto implements IPagedResultDtoOfContactTitleDto {
    totalCount: number | undefined;
    items: ContactTitleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContactTitleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfContactTitleDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfContactTitleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfContactTitleDto {
    totalCount: number | undefined;
    items: ContactTitleDto[] | undefined;
}

export class ContactTitleDto implements IContactTitleDto {
    name: string | undefined;
    isActive: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IContactTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ContactTitleDto {
        const json = this.toJSON();
        let result = new ContactTitleDto();
        result.init(json);
        return result;
    }
}

export interface IContactTitleDto {
    name: string | undefined;
    isActive: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreateCustomerDto implements ICreateCustomerDto {
    userId: number | undefined;
    fName: string;
    lName: string;
    companyName: string | undefined;
    address: string;
    city: string;
    state: string | undefined;
    country: string;
    zip: string;
    email: string;
    telephone: string;
    fax: string | undefined;
    suserid: string | undefined;
    adActiveDate: moment.Moment | undefined;
    adExpiresDate: moment.Moment | undefined;
    bdActiveDate: moment.Moment | undefined;
    imagePath: string | undefined;
    isSalesPerson: boolean | undefined;
    subType: number | undefined;
    notes: string | undefined;
    agencyRec: number | undefined;
    agencyRecPrice: number | undefined;
    contactRec: number | undefined;
    contactRecPrice: number | undefined;

    constructor(data?: ICreateCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.fName = data["fName"];
            this.lName = data["lName"];
            this.companyName = data["companyName"];
            this.address = data["address"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.zip = data["zip"];
            this.email = data["email"];
            this.telephone = data["telephone"];
            this.fax = data["fax"];
            this.suserid = data["suserid"];
            this.adActiveDate = data["adActiveDate"] ? moment(data["adActiveDate"].toString()) : <any>undefined;
            this.adExpiresDate = data["adExpiresDate"] ? moment(data["adExpiresDate"].toString()) : <any>undefined;
            this.bdActiveDate = data["bdActiveDate"] ? moment(data["bdActiveDate"].toString()) : <any>undefined;
            this.imagePath = data["imagePath"];
            this.isSalesPerson = data["isSalesPerson"];
            this.subType = data["subType"];
            this.notes = data["notes"];
            this.agencyRec = data["agencyRec"];
            this.agencyRecPrice = data["agencyRecPrice"];
            this.contactRec = data["contactRec"];
            this.contactRecPrice = data["contactRecPrice"];
        }
    }

    static fromJS(data: any): CreateCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["fName"] = this.fName;
        data["lName"] = this.lName;
        data["companyName"] = this.companyName;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zip"] = this.zip;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["fax"] = this.fax;
        data["suserid"] = this.suserid;
        data["adActiveDate"] = this.adActiveDate ? this.adActiveDate.toISOString() : <any>undefined;
        data["adExpiresDate"] = this.adExpiresDate ? this.adExpiresDate.toISOString() : <any>undefined;
        data["bdActiveDate"] = this.bdActiveDate ? this.bdActiveDate.toISOString() : <any>undefined;
        data["imagePath"] = this.imagePath;
        data["isSalesPerson"] = this.isSalesPerson;
        data["subType"] = this.subType;
        data["notes"] = this.notes;
        data["agencyRec"] = this.agencyRec;
        data["agencyRecPrice"] = this.agencyRecPrice;
        data["contactRec"] = this.contactRec;
        data["contactRecPrice"] = this.contactRecPrice;
        return data; 
    }

    clone(): CreateCustomerDto {
        const json = this.toJSON();
        let result = new CreateCustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCustomerDto {
    userId: number | undefined;
    fName: string;
    lName: string;
    companyName: string | undefined;
    address: string;
    city: string;
    state: string | undefined;
    country: string;
    zip: string;
    email: string;
    telephone: string;
    fax: string | undefined;
    suserid: string | undefined;
    adActiveDate: moment.Moment | undefined;
    adExpiresDate: moment.Moment | undefined;
    bdActiveDate: moment.Moment | undefined;
    imagePath: string | undefined;
    isSalesPerson: boolean | undefined;
    subType: number | undefined;
    notes: string | undefined;
    agencyRec: number | undefined;
    agencyRecPrice: number | undefined;
    contactRec: number | undefined;
    contactRecPrice: number | undefined;
}

export class PagedResultDtoOfUserProfileDto implements IPagedResultDtoOfUserProfileDto {
    totalCount: number | undefined;
    items: UserProfileDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserProfileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserProfileDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserProfileDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserProfileDto {
    totalCount: number | undefined;
    items: UserProfileDto[] | undefined;
}

export class UserProfileDto implements IUserProfileDto {
    userId: number | undefined;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleIds: number[] | undefined;
    adActiveDate: moment.Moment | undefined;
    adExpireDate: moment.Moment | undefined;
    bdActiveDate: moment.Moment | undefined;
    salesUser: string | undefined;
    companyName: string | undefined;
    imagePath: string | undefined;
    isSalesPerson: boolean | undefined;
    id: number | undefined;

    constructor(data?: IUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleIds"] && data["roleIds"].constructor === Array) {
                this.roleIds = [];
                for (let item of data["roleIds"])
                    this.roleIds.push(item);
            }
            this.adActiveDate = data["adActiveDate"] ? moment(data["adActiveDate"].toString()) : <any>undefined;
            this.adExpireDate = data["adExpireDate"] ? moment(data["adExpireDate"].toString()) : <any>undefined;
            this.bdActiveDate = data["bdActiveDate"] ? moment(data["bdActiveDate"].toString()) : <any>undefined;
            this.salesUser = data["salesUser"];
            this.companyName = data["companyName"];
            this.imagePath = data["imagePath"];
            this.isSalesPerson = data["isSalesPerson"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleIds && this.roleIds.constructor === Array) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["adActiveDate"] = this.adActiveDate ? this.adActiveDate.toISOString() : <any>undefined;
        data["adExpireDate"] = this.adExpireDate ? this.adExpireDate.toISOString() : <any>undefined;
        data["bdActiveDate"] = this.bdActiveDate ? this.bdActiveDate.toISOString() : <any>undefined;
        data["salesUser"] = this.salesUser;
        data["companyName"] = this.companyName;
        data["imagePath"] = this.imagePath;
        data["isSalesPerson"] = this.isSalesPerson;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserProfileDto {
        const json = this.toJSON();
        let result = new UserProfileDto();
        result.init(json);
        return result;
    }
}

export interface IUserProfileDto {
    userId: number | undefined;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleIds: number[] | undefined;
    adActiveDate: moment.Moment | undefined;
    adExpireDate: moment.Moment | undefined;
    bdActiveDate: moment.Moment | undefined;
    salesUser: string | undefined;
    companyName: string | undefined;
    imagePath: string | undefined;
    isSalesPerson: boolean | undefined;
    id: number | undefined;
}

export class SalespersonDto implements ISalespersonDto {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: ISalespersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SalespersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalespersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): SalespersonDto {
        const json = this.toJSON();
        let result = new SalespersonDto();
        result.init(json);
        return result;
    }
}

export interface ISalespersonDto {
    name: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfCustomerDto implements IPagedResultDtoOfCustomerDto {
    totalCount: number | undefined;
    items: CustomerDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCustomerDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCustomerDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCustomerDto {
    totalCount: number | undefined;
    items: CustomerDto[] | undefined;
}

export class SendEmailInput implements ISendEmailInput {
    subject: string | undefined;
    body: string | undefined;
    targetUser: string | undefined;

    constructor(data?: ISendEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subject = data["subject"];
            this.body = data["body"];
            this.targetUser = data["targetUser"];
        }
    }

    static fromJS(data: any): SendEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["targetUser"] = this.targetUser;
        return data; 
    }

    clone(): SendEmailInput {
        const json = this.toJSON();
        let result = new SendEmailInput();
        result.init(json);
        return result;
    }
}

export interface ISendEmailInput {
    subject: string | undefined;
    body: string | undefined;
    targetUser: string | undefined;
}

export class PagedResultDtoOfPaymentDto implements IPagedResultDtoOfPaymentDto {
    totalCount: number | undefined;
    items: PaymentDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PaymentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPaymentDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPaymentDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPaymentDto {
    totalCount: number | undefined;
    items: PaymentDto[] | undefined;
}

export class PaymentDto implements IPaymentDto {
    orderType: OrderType | undefined;
    orderAmount: number | undefined;
    creditCardMusked: string | undefined;
    transactionId: string | undefined;
    externalTransactionId: string | undefined;
    customerName: string | undefined;
    companyName: string | undefined;
    paymentType: PaymentType | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderType = data["orderType"] ? OrderType.fromJS(data["orderType"]) : <any>undefined;
            this.orderAmount = data["orderAmount"];
            this.creditCardMusked = data["creditCardMusked"];
            this.transactionId = data["transactionId"];
            this.externalTransactionId = data["externalTransactionId"];
            this.customerName = data["customerName"];
            this.companyName = data["companyName"];
            this.paymentType = data["paymentType"] ? PaymentType.fromJS(data["paymentType"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderType"] = this.orderType ? this.orderType.toJSON() : <any>undefined;
        data["orderAmount"] = this.orderAmount;
        data["creditCardMusked"] = this.creditCardMusked;
        data["transactionId"] = this.transactionId;
        data["externalTransactionId"] = this.externalTransactionId;
        data["customerName"] = this.customerName;
        data["companyName"] = this.companyName;
        data["paymentType"] = this.paymentType ? this.paymentType.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PaymentDto {
        const json = this.toJSON();
        let result = new PaymentDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentDto {
    orderType: OrderType | undefined;
    orderAmount: number | undefined;
    creditCardMusked: string | undefined;
    transactionId: string | undefined;
    externalTransactionId: string | undefined;
    customerName: string | undefined;
    companyName: string | undefined;
    paymentType: PaymentType | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OrderType implements IOrderType {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: IOrderType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrderType {
        data = typeof data === 'object' ? data : {};
        let result = new OrderType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrderType {
        const json = this.toJSON();
        let result = new OrderType();
        result.init(json);
        return result;
    }
}

export interface IOrderType {
    name: string | undefined;
    id: number | undefined;
}

export class PaymentType implements IPaymentType {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: IPaymentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PaymentType {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): PaymentType {
        const json = this.toJSON();
        let result = new PaymentType();
        result.init(json);
        return result;
    }
}

export interface IPaymentType {
    name: string | undefined;
    id: number | undefined;
}

export class PaymentInput implements IPaymentInput {
    orderTypeId: PaymentInputOrderTypeId | undefined;
    orderAmount: number | undefined;
    creditCardMusked: string | undefined;
    transactionId: string | undefined;
    externalTransactionId: string | undefined;
    customerName: string | undefined;
    companyName: string | undefined;
    paymentTypeId: PaymentInputPaymentTypeId | undefined;

    constructor(data?: IPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderTypeId = data["orderTypeId"];
            this.orderAmount = data["orderAmount"];
            this.creditCardMusked = data["creditCardMusked"];
            this.transactionId = data["transactionId"];
            this.externalTransactionId = data["externalTransactionId"];
            this.customerName = data["customerName"];
            this.companyName = data["companyName"];
            this.paymentTypeId = data["paymentTypeId"];
        }
    }

    static fromJS(data: any): PaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderTypeId"] = this.orderTypeId;
        data["orderAmount"] = this.orderAmount;
        data["creditCardMusked"] = this.creditCardMusked;
        data["transactionId"] = this.transactionId;
        data["externalTransactionId"] = this.externalTransactionId;
        data["customerName"] = this.customerName;
        data["companyName"] = this.companyName;
        data["paymentTypeId"] = this.paymentTypeId;
        return data; 
    }

    clone(): PaymentInput {
        const json = this.toJSON();
        let result = new PaymentInput();
        result.init(json);
        return result;
    }
}

export interface IPaymentInput {
    orderTypeId: PaymentInputOrderTypeId | undefined;
    orderAmount: number | undefined;
    creditCardMusked: string | undefined;
    transactionId: string | undefined;
    externalTransactionId: string | undefined;
    customerName: string | undefined;
    companyName: string | undefined;
    paymentTypeId: PaymentInputPaymentTypeId | undefined;
}

export class PaymentRequestDto implements IPaymentRequestDto {
    amount: number | undefined;
    credit_card: CreditCardDto | undefined;
    csc: string | undefined;
    billing_address: BillingAddressDto | undefined;
    external_transaction_id: string | undefined;

    constructor(data?: IPaymentRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.credit_card = data["credit_card"] ? CreditCardDto.fromJS(data["credit_card"]) : <any>undefined;
            this.csc = data["csc"];
            this.billing_address = data["billing_address"] ? BillingAddressDto.fromJS(data["billing_address"]) : <any>undefined;
            this.external_transaction_id = data["external_transaction_id"];
        }
    }

    static fromJS(data: any): PaymentRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["credit_card"] = this.credit_card ? this.credit_card.toJSON() : <any>undefined;
        data["csc"] = this.csc;
        data["billing_address"] = this.billing_address ? this.billing_address.toJSON() : <any>undefined;
        data["external_transaction_id"] = this.external_transaction_id;
        return data; 
    }

    clone(): PaymentRequestDto {
        const json = this.toJSON();
        let result = new PaymentRequestDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentRequestDto {
    amount: number | undefined;
    credit_card: CreditCardDto | undefined;
    csc: string | undefined;
    billing_address: BillingAddressDto | undefined;
    external_transaction_id: string | undefined;
}

export class CreditCardDto implements ICreditCardDto {
    number: string | undefined;
    expiration_month: string | undefined;
    expiration_year: string | undefined;

    constructor(data?: ICreditCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.number = data["number"];
            this.expiration_month = data["expiration_month"];
            this.expiration_year = data["expiration_year"];
        }
    }

    static fromJS(data: any): CreditCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["expiration_month"] = this.expiration_month;
        data["expiration_year"] = this.expiration_year;
        return data; 
    }

    clone(): CreditCardDto {
        const json = this.toJSON();
        let result = new CreditCardDto();
        result.init(json);
        return result;
    }
}

export interface ICreditCardDto {
    number: string | undefined;
    expiration_month: string | undefined;
    expiration_year: string | undefined;
}

export class BillingAddressDto implements IBillingAddressDto {
    name: string | undefined;
    street_address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    zip: string | undefined;

    constructor(data?: IBillingAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.street_address = data["street_address"];
            this.city = data["city"];
            this.state = data["state"];
            this.zip = data["zip"];
        }
    }

    static fromJS(data: any): BillingAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["street_address"] = this.street_address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        return data; 
    }

    clone(): BillingAddressDto {
        const json = this.toJSON();
        let result = new BillingAddressDto();
        result.init(json);
        return result;
    }
}

export interface IBillingAddressDto {
    name: string | undefined;
    street_address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    zip: string | undefined;
}

export class KeyedSaleResponse implements IKeyedSaleResponse {
    masked_card_number: string | undefined;
    approval_code: string | undefined;
    approval_message: string | undefined;
    avs_response: string | undefined;
    csc_response: string | undefined;
    external_transaction_id: string | undefined;
    success: boolean | undefined;
    response_code: number | undefined;
    status_message: string | undefined;
    transaction_id: number | undefined;
    httpErrorMessage: string | undefined;
    errors: { [key: string] : string[]; } | undefined;

    constructor(data?: IKeyedSaleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.masked_card_number = data["masked_card_number"];
            this.approval_code = data["approval_code"];
            this.approval_message = data["approval_message"];
            this.avs_response = data["avs_response"];
            this.csc_response = data["csc_response"];
            this.external_transaction_id = data["external_transaction_id"];
            this.success = data["success"];
            this.response_code = data["response_code"];
            this.status_message = data["status_message"];
            this.transaction_id = data["transaction_id"];
            this.httpErrorMessage = data["httpErrorMessage"];
            if (data["errors"]) {
                this.errors = {};
                for (let key in data["errors"]) {
                    if (data["errors"].hasOwnProperty(key))
                        this.errors[key] = data["errors"][key] !== undefined ? data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): KeyedSaleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new KeyedSaleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masked_card_number"] = this.masked_card_number;
        data["approval_code"] = this.approval_code;
        data["approval_message"] = this.approval_message;
        data["avs_response"] = this.avs_response;
        data["csc_response"] = this.csc_response;
        data["external_transaction_id"] = this.external_transaction_id;
        data["success"] = this.success;
        data["response_code"] = this.response_code;
        data["status_message"] = this.status_message;
        data["transaction_id"] = this.transaction_id;
        data["httpErrorMessage"] = this.httpErrorMessage;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    data["errors"][key] = this.errors[key];
            }
        }
        return data; 
    }

    clone(): KeyedSaleResponse {
        const json = this.toJSON();
        let result = new KeyedSaleResponse();
        result.init(json);
        return result;
    }
}

export interface IKeyedSaleResponse {
    masked_card_number: string | undefined;
    approval_code: string | undefined;
    approval_message: string | undefined;
    avs_response: string | undefined;
    csc_response: string | undefined;
    external_transaction_id: string | undefined;
    success: boolean | undefined;
    response_code: number | undefined;
    status_message: string | undefined;
    transaction_id: number | undefined;
    httpErrorMessage: string | undefined;
    errors: { [key: string] : string[]; } | undefined;
}

export class PagedResultDtoOfPricingRuleDto implements IPagedResultDtoOfPricingRuleDto {
    totalCount: number | undefined;
    items: PricingRuleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPricingRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PricingRuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPricingRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPricingRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPricingRuleDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPricingRuleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPricingRuleDto {
    totalCount: number | undefined;
    items: PricingRuleDto[] | undefined;
}

export class PricingRuleDto implements IPricingRuleDto {
    title: string | undefined;
    perCreditRate: number | undefined;
    noRecords: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IPricingRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.perCreditRate = data["perCreditRate"];
            this.noRecords = data["noRecords"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PricingRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PricingRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["perCreditRate"] = this.perCreditRate;
        data["noRecords"] = this.noRecords;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PricingRuleDto {
        const json = this.toJSON();
        let result = new PricingRuleDto();
        result.init(json);
        return result;
    }
}

export interface IPricingRuleDto {
    title: string | undefined;
    perCreditRate: number | undefined;
    noRecords: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreatePricingRuleInput implements ICreatePricingRuleInput {
    title: string;
    perCreditRate: number | undefined;

    constructor(data?: ICreatePricingRuleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.perCreditRate = data["perCreditRate"];
        }
    }

    static fromJS(data: any): CreatePricingRuleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePricingRuleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["perCreditRate"] = this.perCreditRate;
        return data; 
    }

    clone(): CreatePricingRuleInput {
        const json = this.toJSON();
        let result = new CreatePricingRuleInput();
        result.init(json);
        return result;
    }
}

export interface ICreatePricingRuleInput {
    title: string;
    perCreditRate: number | undefined;
}

export class PagedResultDtoOfProductLineDto implements IPagedResultDtoOfProductLineDto {
    totalCount: number | undefined;
    items: ProductLineDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ProductLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfProductLineDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfProductLineDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfProductLineDto {
    totalCount: number | undefined;
    items: ProductLineDto[] | undefined;
}

export class ProductLineDto implements IProductLineDto {
    name: string | undefined;
    isActive: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IProductLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProductLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProductLineDto {
        const json = this.toJSON();
        let result = new ProductLineDto();
        result.init(json);
        return result;
    }
}

export interface IProductLineDto {
    name: string | undefined;
    isActive: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;
    id: number | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPermissionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfSubscriptionPlanDto implements IPagedResultDtoOfSubscriptionPlanDto {
    totalCount: number | undefined;
    items: SubscriptionPlanDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscriptionPlanDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfSubscriptionPlanDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSubscriptionPlanDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSubscriptionPlanDto {
    totalCount: number | undefined;
    items: SubscriptionPlanDto[] | undefined;
}

export class SubscriptionPlanDto implements ISubscriptionPlanDto {
    typeName: string | undefined;
    amount: number | undefined;
    options: string | undefined;
    accessLevel: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ISubscriptionPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeName = data["typeName"];
            this.amount = data["amount"];
            this.options = data["options"];
            this.accessLevel = data["accessLevel"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["amount"] = this.amount;
        data["options"] = this.options;
        data["accessLevel"] = this.accessLevel;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SubscriptionPlanDto {
        const json = this.toJSON();
        let result = new SubscriptionPlanDto();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanDto {
    typeName: string | undefined;
    amount: number | undefined;
    options: string | undefined;
    accessLevel: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreateSubscriptionPlanInput implements ICreateSubscriptionPlanInput {
    typeName: string | undefined;
    amount: number | undefined;
    options: string | undefined;
    accessLevel: string | undefined;

    constructor(data?: ICreateSubscriptionPlanInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeName = data["typeName"];
            this.amount = data["amount"];
            this.options = data["options"];
            this.accessLevel = data["accessLevel"];
        }
    }

    static fromJS(data: any): CreateSubscriptionPlanInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubscriptionPlanInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["amount"] = this.amount;
        data["options"] = this.options;
        data["accessLevel"] = this.accessLevel;
        return data; 
    }

    clone(): CreateSubscriptionPlanInput {
        const json = this.toJSON();
        let result = new CreateSubscriptionPlanInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSubscriptionPlanInput {
    typeName: string | undefined;
    amount: number | undefined;
    options: string | undefined;
    accessLevel: string | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfTenantDto implements IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adminPassword = data["adminPassword"];
            this.userId = data["userId"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;
}

export enum ReportType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
}

export enum PurchaseType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum ADOrderInputOrderType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
    _12 = 12, 
    _13 = 13, 
}

export enum JSonResultDtoStatus {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum PurchaseInputPurchaseType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum PaymentInputOrderTypeId {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum PaymentInputPaymentTypeId {
    _1 = 1, 
    _2 = 2, 
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}